{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"diffWOFOST","text":""},{"location":"#diffwofost-differentiable-wofost","title":"diffWOFOST: Differentiable WOFOST","text":"<p>The package diffWOFOST contains a differentiable implementation of the WOFOST crop growth models using <code>pytorch</code> and <code>PCSE</code>. The implementation allows for automatic differentiation, enabling gradient-based optimization, sensitivity analysis and data assimilation.</p> <p>In PCSE, WOFOST models are categorized based on <code>version, productionlevel, waterbalance, nitrogenbalance</code> and each model contains a set of elements e.g. crop and soil models, see models available in PCSE and PCSE Engine.</p> <p>In diffWOFOST, each element is implemented as a differentiable module, using torch.Tensor, allowing for end-to-end differentiation of the entire WOFOST model. To develop a differentiable module, we check for look-up tables, hard thresholds, and mathematical operations, and replace them with differentiable alternatives.</p> <p>In addition to differentiability, the implementation also focuses on efficiency, by leveraging vectorized operations. This is particularly important for large-scale simulations and training workflows, where the computational cost can be significant.</p>"},{"location":"#hybrid-modelling-with-diffwofost","title":"Hybrid modelling with diffWOFOST","text":"<p>Hybrid modelling, referring to a combination of process-based and machine-learning modelling, has recently emerged as a promising line of research to harness the strengths of both approaches while mitigating their respective weaknesses, see Integrating Scientific Knowledge with Machine Learning for Engineering and Environmental Systems and Deep learning and process understanding for data-driven Earth system science.</p> <p>The approach where an machine learning (ML) model predicts physical parameters, which are then used in a physics-based model, and combines both in a hybrid architecture, is a state-of-the-art approach and is known under various names, see Scientific Machine Learning. The mathematics would be:</p> \\[ \\frac{\\partial \\text{loss}}{\\partial \\text{(ML model weights)}} = \\frac{\\partial \\text{loss}}{\\partial \\text{(physics-based model output)}} \\cdot \\frac{\\partial \\text{(physics-based model output)}}{\\partial \\text{(physics-based model parameters)}} \\cdot \\frac{\\partial \\text{(physics-based model parameters)}}{\\partial \\text{(ML model weights)}} \\] <p>And code wise, this would look like:</p> <pre><code>import torch.nn as nn\n\n# Step 1: ML model that outputs physical parameters e.g. LSTM\nclass MLModel(nn.Module):\n    def __init__(self, input_size, hidden_size, num_physical_params):\n        super().__init__()\n        self.lstm = nn.LSTM(input_size=input_size, hidden_size=hidden_size, batch_first=True)\n        self.linear = nn.Linear(hidden_size, num_physical_params)\n\n    def forward(self, x):\n        lstm_out, _ = self.lstm(x)\n        physical_params = self.linear(lstm_out[:, -1, :])\n        return physical_params\n\n# Step 2: Physical model i.e. a differentiable WOFOST model e.g. Wofost72_PP\nclass PhysicalModel(nn.Module):\n    def __init__(self, dt):\n        super().__init__()\n\n    def forward(self, params):\n        model = Wofost72_PP(params, ...)  # this is differentiable version\n        model.run_till_terminate()  # finish the simulation\n        output = model.get_output()\n        return output\n\n# Step 3: Hybrid model integrating ML and physical model\nclass HybridModel(nn.Module):\n    def __init__(self, input_size, hidden_size, num_physical_params):\n        super().__init__()\n        self.ml_model = MLModel(input_size, hidden_size, num_physical_params)\n        self.physical_model = PhysicalModel()\n\n    def forward(self, x):\n        physical_params = self.ml_model(x)\n        output = self.physical_model(physical_params)\n        return output, physical_params\n</code></pre>"},{"location":"#code-structure-under-development","title":"Code structure (under development)","text":"<p>The package is structured as follows:</p> <pre><code>\u251c\u2500\u2500 physical_models/\n        \u251c\u2500\u2500 crop/  # differentiable implementation of each crop model\n        \u2502   \u251c\u2500\u2500 leaf_dynamics.py\n        \u2502   \u251c\u2500\u2500 root_dynamics.py\n        \u2502   \u251c\u2500\u2500 ...\n        \u251c\u2500\u2500 soil/\n        \u251c\u2500\u2500 utils.py  # helpers\n</code></pre> <p>Note</p> <p>At the moment only two modules of <code>leaf_dynamics</code> and <code>root_dynamics</code> are differentiable w.r.t two parameters of <code>SPAN</code> and <code>TDWI</code>. But the package is under continuous development. So make sure that you install the latest version.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [...]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p>"},{"location":"CONTRIBUTING/","title":"Contributing guide","text":"<p>We welcome any kind of contribution to our software, from simple comment or question to a full fledged pull request. Please read and follow our Code of Conduct.</p> <p>A contribution can be one of the following cases:</p> <ol> <li>you have a question;</li> <li>you think you may have found a bug (including unexpected behavior);</li> <li>you want to make some kind of change to the code base (e.g. to fix a bug, to add a new feature, to update documentation);</li> <li>you want to make a new release of the code base.</li> </ol> <p>The sections below outline the steps in each case.</p>"},{"location":"CONTRIBUTING/#you-have-a-question","title":"You have a question","text":"<ol> <li>use the search functionality in    issues to see if someone    already filed the same issue;</li> <li>if your issue search did not yield any relevant results, make a new issue;</li> <li>apply the \"Question\" label; apply other labels when relevant.</li> </ol>"},{"location":"CONTRIBUTING/#you-think-you-may-have-found-a-bug","title":"You think you may have found a bug","text":"<ol> <li>use the search functionality in    issues to see if someone    already filed the same issue;</li> <li>if your issue search did not yield any relevant results, make a new issue,    making sure to provide enough information to the rest of the community to    understand the cause and context of the problem.</li> </ol>"},{"location":"CONTRIBUTING/#you-want-to-make-some-kind-of-change-to-the-code-base","title":"You want to make some kind of change to the code base","text":"<ol> <li>(important) announce your plan to the rest of the community before you    start working. This announcement should be in the form of a (new) issue;</li> <li>(important) wait until some kind of consensus is reached about your idea being a good idea;</li> <li>follow the instruction in developer_guide.md.</li> </ol> <p>In case you feel like you've made a valuable contribution, but you don't know how to write or run tests for it, or how to generate the documentation: don't let this discourage you from making the pull request; we can help you! Just go ahead and submit an issue and ask your questions.</p>"},{"location":"CONTRIBUTING/#you-want-to-make-a-new-release-of-the-code-base","title":"You want to make a new release of the code base","text":"<p>To create a release you need write permission on the repository.</p> <ol> <li>Check the author list in <code>CITATION.cff</code>in    the root of the repository.</li> <li>Bump the version. The version can be manually changed in <code>pyproject.toml</code> in    the root of the repository. Follow Semantic Versioning    principles. Also, update <code>__version__</code> variable in <code>diffwofost/__init__.py</code> to the    same version.</li> <li>Go to the GitHub release    page. Press draft a new    release button. Fill version, title and description field. Press the Publish    Release button. For this package, the zenodo integration is enabled, so a new    DOI will be created automatically.</li> <li>This software automatically publish to PyPI using a release or publish    workflow. Wait until PyPi publish    workflow    has completed and verify new release is on    PyPi</li> </ol>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>The package <code>diffWOFOST</code> is developed in the DeltaCrop project, a collaboration between Wageningen University &amp; Research and Netherlands eScience Center.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#crop-modules","title":"Crop modules","text":"<p>Note</p> <p>At the moment only two modules of <code>leaf_dynamics</code> and <code>root_dynamics</code> are differentiable w.r.t two parameters of <code>SPAN</code> and <code>TDWI</code>. But the package is under continuous development. So make sure that you install the latest version.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics","title":"diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Leaf dynamics for the WOFOST crop model.</p> <p>Implementation of biomass partitioning to leaves, growth and senenscence of leaves. WOFOST keeps track of the biomass that has been partitioned to the leaves for each day (variable <code>LV</code>), which is called a leaf class). For each leaf class the leaf age (variable 'LVAGE') and specific leaf area (variable <code>SLA</code>) are also registered. Total living leaf biomass is calculated by summing the biomass values for all leaf classes. Similarly, leaf area is calculated by summing leaf biomass times specific leaf area (<code>LV</code> * <code>SLA</code>).</p> <p>Senescense of the leaves can occur as a result of physiological age, drought stress or self-shading.</p> <p>Simulation parameters (provide in cropdata dictionary)</p> Name Description Type Unit RGRLAI Maximum relative increase in LAI. SCr ha ha\u207b\u00b9 d\u207b\u00b9 SPAN Life span of leaves growing at 35 Celsius SCr d TBASE Lower threshold temp. for ageing of leaves SCr C PERDL Max. relative death rate of leaves due to water stress SCr TDWI Initial total crop dry weight SCr kg ha\u207b\u00b9 KDIFTB Extinction coefficient for diffuse visible light as function of DVS TCr SLATB Specific leaf area as a function of DVS TCr ha kg\u207b\u00b9 <p>State variables</p> Name Description Pbl Unit LV Leaf biomass per leaf class N kg ha\u207b\u00b9 SLA Specific leaf area per leaf class N ha kg\u207b\u00b9 LVAGE Leaf age per leaf class N d LVSUM Sum of LV N kg ha\u207b\u00b9 LAIEM LAI at emergence N - LASUM Total leaf area as sum of LV*SLA, not including stem and pod area N - LAIEXP LAI value under theoretical exponential growth N - LAIMAX Maximum LAI reached during growth cycle N - LAI Leaf area index, including stem and pod area Y - WLV Dry weight of living leaves Y kg ha\u207b\u00b9 DWLV Dry weight of dead leaves N kg ha\u207b\u00b9 TWLV Dry weight of total leaves (living + dead) Y kg ha\u207b\u00b9 <p>Rate variables</p> Name Description Pbl Unit GRLV Growth rate leaves N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV1 Death rate leaves due to water stress N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV2 Death rate leaves due to self-shading N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV3 Death rate leaves due to frost kill N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV Maximum of DSLV1, DSLV2, DSLV3 N kg ha\u207b\u00b9 d\u207b\u00b9 DALV Death rate leaves due to aging N kg ha\u207b\u00b9 d\u207b\u00b9 DRLV Death rate leaves as a combination of DSLV and DALV N kg ha\u207b\u00b9 d\u207b\u00b9 SLAT Specific leaf area for current time step, adjusted for source/sink limited leaf expansion rate N ha kg\u207b\u00b9 FYSAGE Increase in physiological leaf age N - GLAIEX Sink-limited leaf expansion rate (exponential curve) N ha ha\u207b\u00b9 d\u207b\u00b9 GLASOL Source-limited leaf expansion rate (biomass increase) N ha ha\u207b\u00b9 d\u207b\u00b9 <p>External dependencies</p> Name Description Provided by Unit DVS Crop development stage DVS_Phenology - FL Fraction biomass to leaves DVS_Partitioning - FR Fraction biomass to roots DVS_Partitioning - SAI Stem area index WOFOST_Stem_Dynamics - PAI Pod area index WOFOST_Storage_Organ_Dynamics - TRA Transpiration rate Evapotranspiration cm day\u207b\u00b9 ? TRAMX Maximum transpiration rate Evapotranspiration cm day\u207b\u00b9 ? ADMI Above-ground dry matter increase CropSimulation kg ha\u207b\u00b9 d\u207b\u00b9 RFTRA Reduction factor for transpiration (water &amp; oxygen) Y - RF_FROST Reduction factor frost kill FROSTOL (optional) - <p>Outputs</p> Name Description Pbl Unit LAI Leaf area index, including stem and pod area Y - TWLV Dry weight of total leaves (living + dead) Y kg ha\u207b\u00b9 <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>Initialize the WOFOST_Leaf_Dynamics simulation object.</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Calculate the rates of change for the leaf dynamics.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate the leaf dynamics state variables.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.initialize","title":"initialize","text":"<pre><code>initialize(day: date, kiosk: VariableKiosk, parvalues: ParameterProvider) -&gt; None\n</code></pre> <p>Initialize the WOFOST_Leaf_Dynamics simulation object.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The starting date of the simulation.</p> </li> <li> <code>kiosk</code>               (<code>VariableKiosk</code>)           \u2013            <p>A container for registering and publishing (internal and external) state variables. See PCSE documentation for details.</p> </li> <li> <code>parvalues</code>               (<code>ParameterProvider</code>)           \u2013            <p>A dictionary-like container holding all parameter sets (crop, soil, site) as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/leaf_dynamics.py</code> <pre><code>def initialize(\n    self, day: datetime.date, kiosk: VariableKiosk, parvalues: ParameterProvider\n) -&gt; None:\n    \"\"\"Initialize the WOFOST_Leaf_Dynamics simulation object.\n\n    Args:\n        day (datetime.date): The starting date of the simulation.\n        kiosk (VariableKiosk): A container for registering and publishing\n            (internal and external) state variables. See PCSE documentation for\n            details.\n        parvalues (ParameterProvider): A dictionary-like container holding\n            all parameter sets (crop, soil, site) as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    self.START_DATE = day\n    self.kiosk = kiosk\n    # TODO check if parvalues are already torch.nn.Parameters\n    self.params = self.Parameters(parvalues)\n    self.rates = self.RateVariables(kiosk)\n\n    # CALCULATE INITIAL STATE VARIABLES\n    # check for required external variables\n    _exist_required_external_variables(self.kiosk)\n    # TODO check if external variables are already torch tensors\n\n    FL = self.kiosk[\"FL\"]\n    FR = self.kiosk[\"FR\"]\n    DVS = self.kiosk[\"DVS\"]\n\n    params = self.params\n    shape = _get_params_shape(params)\n\n    # Initial leaf biomass\n    WLV = (params.TDWI * (1 - FR)) * FL\n    DWLV = torch.zeros(shape, dtype=DTYPE)\n    TWLV = WLV + DWLV\n\n    # Initialize leaf classes (SLA, age and weight)\n    SLA = torch.zeros((*shape, self.MAX_DAYS), dtype=DTYPE)\n    LVAGE = torch.zeros((*shape, self.MAX_DAYS), dtype=DTYPE)\n    LV = torch.zeros((*shape, self.MAX_DAYS), dtype=DTYPE)\n    SLA[..., 0] = params.SLATB(DVS)\n    LV[..., 0] = WLV\n\n    # Initial values for leaf area\n    LAIEM = LV[..., 0] * SLA[..., 0]\n    LASUM = LAIEM\n    LAIEXP = LAIEM\n    LAIMAX = LAIEM\n    LAI = LASUM + self.kiosk[\"SAI\"] + self.kiosk[\"PAI\"]\n\n    # Initialize StateVariables object\n    self.states = self.StateVariables(\n        kiosk,\n        publish=[\"LAI\", \"TWLV\", \"WLV\"],\n        LV=LV,\n        SLA=SLA,\n        LVAGE=LVAGE,\n        LAIEM=LAIEM,\n        LASUM=LASUM,\n        LAIEXP=LAIEXP,\n        LAIMAX=LAIMAX,\n        LAI=LAI,\n        WLV=WLV,\n        DWLV=DWLV,\n        TWLV=TWLV,\n    )\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day: date, drv: WeatherDataContainer) -&gt; None\n</code></pre> <p>Calculate the rates of change for the leaf dynamics.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>drv</code>               (<code>WeatherDataContainer</code>)           \u2013            <p>A dictionary-like container holding weather data elements as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/leaf_dynamics.py</code> <pre><code>@prepare_rates\ndef calc_rates(self, day: datetime.date, drv: WeatherDataContainer) -&gt; None:\n    \"\"\"Calculate the rates of change for the leaf dynamics.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        drv (WeatherDataContainer, optional): A dictionary-like container holding\n            weather data elements as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    r = self.rates\n    s = self.states\n    p = self.params\n    k = self.kiosk\n\n    # If DVS &lt; 0, the crop has not yet emerged, so we zerofy the rates using mask\n    # Make a mask (0 if DVS &lt; 0, 1 if DVS &gt;= 0)\n    DVS = torch.as_tensor(k[\"DVS\"], dtype=DTYPE)\n    mask = (DVS &gt;= 0).to(dtype=DTYPE)\n\n    # Growth rate leaves\n    # weight of new leaves\n    r.GRLV = mask * k.ADMI * k.FL\n\n    # death of leaves due to water/oxygen stress\n    r.DSLV1 = mask * s.WLV * (1.0 - k.RFTRA) * p.PERDL\n\n    # death due to self shading cause by high LAI\n    DVS = self.kiosk[\"DVS\"]\n    LAICR = 3.2 / p.KDIFTB(DVS)\n    r.DSLV2 = mask * s.WLV * torch.clamp(0.03 * (s.LAI - LAICR) / LAICR, 0.0, 0.03)\n\n    # Death of leaves due to frost damage as determined by\n    # Reduction Factor Frost \"RF_FROST\"\n    if \"RF_FROST\" in self.kiosk:\n        r.DSLV3 = mask * s.WLV * k.RF_FROST\n    else:\n        r.DSLV3 = torch.zeros_like(s.WLV, dtype=DTYPE)\n\n    # leaf death equals maximum of water stress, shading and frost\n    r.DSLV = torch.maximum(torch.maximum(r.DSLV1, r.DSLV2), r.DSLV3)\n\n    # Determine how much leaf biomass classes have to die in states.LV,\n    # given the a life span &gt; SPAN, these classes will be accumulated\n    # in DALV.\n    # Note that the actual leaf death is imposed on the array LV during the\n    # state integration step.\n    tSPAN = _broadcast_to(p.SPAN, s.LVAGE.shape)  # Broadcast to same shape\n    # Using a sigmoid here instead of a conditional statement on the value of\n    # SPAN because the latter would not allow for the gradient to be tracked.\n    sharpness = torch.tensor(1000.0, dtype=DTYPE)  # FIXME\n    weight = torch.sigmoid((s.LVAGE - tSPAN) * sharpness)\n    r.DALV = torch.sum(weight * s.LV, dim=-1)\n\n    # Total death rate leaves\n    r.DRLV = torch.maximum(r.DSLV, r.DALV)\n\n    # physiologic ageing of leaves per time step\n    FYSAGE = (drv.TEMP - p.TBASE) / (35.0 - p.TBASE)\n    r.FYSAGE = mask * torch.clamp(FYSAGE, 0.0)\n\n    # specific leaf area of leaves per time step\n    r.SLAT = mask * torch.tensor(p.SLATB(DVS), dtype=DTYPE)\n\n    # leaf area not to exceed exponential growth curve\n    is_lai_exp = s.LAIEXP &lt; 6.0\n    DTEFF = torch.clamp(drv.TEMP - p.TBASE, 0.0)\n    # NOTE: conditional statements do not allow for the gradient to be\n    # tracked through the condition. Thus, the gradient with respect to\n    # parameters that contribute to `is_lai_exp` (e.g. RGRLAI and TBASE)\n    # are expected to be incorrect.\n    r.GLAIEX = torch.where(is_lai_exp, s.LAIEXP * p.RGRLAI * DTEFF, r.GLAIEX)\n    # source-limited increase in leaf area\n    r.GLASOL = torch.where(is_lai_exp, r.GRLV * r.SLAT, r.GLASOL)\n    # sink-limited increase in leaf area\n    GLA = torch.minimum(r.GLAIEX, r.GLASOL)\n    # adjustment of specific leaf area of youngest leaf class\n    r.SLAT = torch.where(is_lai_exp &amp; (r.GRLV &gt; 0.0), GLA / r.GRLV, r.SLAT)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.integrate","title":"integrate","text":"<pre><code>integrate(day: date, delt=1.0) -&gt; None\n</code></pre> <p>Integrate the leaf dynamics state variables.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>delt</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The time step for integration. Defaults to 1.0.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/leaf_dynamics.py</code> <pre><code>@prepare_states\ndef integrate(self, day: datetime.date, delt=1.0) -&gt; None:\n    \"\"\"Integrate the leaf dynamics state variables.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        delt (float, optional): The time step for integration. Defaults to 1.0.\n    \"\"\"\n    # TODO check if DVS &lt; 0 and skip integration needed\n    rates = self.rates\n    states = self.states\n\n    # --------- leave death ---------\n    tLV = states.LV.clone()\n    tSLA = states.SLA.clone()\n    tLVAGE = states.LVAGE.clone()\n    tDRLV = _broadcast_to(rates.DRLV, tLV.shape)\n\n    # Leaf death is imposed on leaves from the oldest ones.\n    # Calculate the cumulative sum of weights after leaf death, and\n    # find out which leaf classes are dead (negative weights)\n    weight_cumsum = tLV.cumsum(dim=-1) - tDRLV\n    is_alive = weight_cumsum &gt;= 0\n\n    # Adjust value of oldest leaf class, i.e. the first non-zero\n    # weight along the time axis (the last dimension).\n    # Cast argument to int because torch.argmax requires it to be numeric\n    idx_oldest = torch.argmax(is_alive.type(torch.int), dim=-1, keepdim=True)\n    new_biomass = torch.take_along_dim(weight_cumsum, indices=idx_oldest, dim=-1)\n    tLV = torch.scatter(tLV, dim=-1, index=idx_oldest, src=new_biomass)\n\n    # Zero out all dead leaf classes\n    # NOTE: conditional statements do not allow for the gradient to be\n    # tracked through the condition. Thus, the gradient with respect to\n    # parameters that contribute to `is_alive` are expected to be incorrect.\n    tLV = torch.where(is_alive, tLV, 0.0)\n\n    # Integration of physiological age\n    tLVAGE = tLVAGE + rates.FYSAGE\n    tLVAGE = torch.where(is_alive, tLVAGE, 0.0)\n    tSLA = torch.where(is_alive, tSLA, 0.0)\n\n    # --------- leave growth ---------\n    idx = int((day - self.START_DATE).days / delt)\n    tLV[..., idx] = rates.GRLV\n    tSLA[..., idx] = rates.SLAT\n    tLVAGE[..., idx] = 0.0\n\n    # calculation of new leaf area\n    states.LASUM = torch.sum(tLV * tSLA, dim=-1)\n    states.LAI = self._calc_LAI()\n    states.LAIMAX = torch.maximum(states.LAI, states.LAIMAX)\n\n    # exponential growth curve\n    states.LAIEXP = states.LAIEXP + rates.GLAIEX\n\n    # Update leaf biomass states\n    states.WLV = torch.sum(tLV, dim=-1)\n    states.DWLV = states.DWLV + rates.DRLV\n    states.TWLV = states.WLV + states.DWLV\n\n    # Store final leaf biomass deques\n    self.states.LV = tLV\n    self.states.SLA = tSLA\n    self.states.LVAGE = tLVAGE\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics","title":"diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Root biomass dynamics and rooting depth.</p> <p>Root growth and root biomass dynamics in WOFOST are separate processes, with the only exception that root growth stops when no more biomass is sent to the root system.</p> <p>Root biomass increase results from the assimilates partitioned to the root system. Root death is defined as the current root biomass multiplied by a relative death rate (<code>RDRRTB</code>). The latter as a function of the development stage (<code>DVS</code>).</p> <p>Increase in root depth is a simple linear expansion over time until the maximum rooting depth (<code>RDM</code>) is reached.</p> <p>Simulation parameters</p> Name Description Type Unit RDI Initial rooting depth SCr cm RRI Daily increase in rooting depth SCr cm day\u207b\u00b9 RDMCR Maximum rooting depth of the crop SCR cm RDMSOL Maximum rooting depth of the soil SSo cm TDWI Initial total crop dry weight SCr kg ha\u207b\u00b9 IAIRDU Presence of air ducts in the root (1) or not (0) SCr - RDRRTB Relative death rate of roots as a function of development stage TCr - <p>State variables</p> Name Description Pbl Unit RD Current rooting depth Y cm RDM Maximum attainable rooting depth at the minimum of the soil and crop maximum rooting depth N cm WRT Weight of living roots Y kg ha\u207b\u00b9 DWRT Weight of dead roots N kg ha\u207b\u00b9 TWRT Total weight of roots Y kg ha\u207b\u00b9 <p>Rate variables</p> Name Description Pbl Unit RR Growth rate root depth N cm GRRT Growth rate root biomass N kg ha\u207b\u00b9 d\u207b\u00b9 DRRT Death rate root biomass N kg ha\u207b\u00b9 d\u207b\u00b9 GWRT Net change in root biomass N kg ha\u207b\u00b9 d\u207b\u00b9 <p>Signals send or handled</p> <p>None</p> <p>External dependencies:</p> Name Description Provided by Unit DVS Crop development stage DVS_Phenology - DMI Total dry matter increase CropSimulation kg ha\u207b\u00b9 d\u207b\u00b9 FR Fraction biomass to roots DVS_Partitioning - <p>Outputs:</p> Name Description Provided by Unit RD Current rooting depth Y cm TWRT Total weight of roots Y kg ha\u207b\u00b9 <p>IMPORTANT NOTICE</p> <p>Currently root development is linear and depends only on the fraction of assimilates send to the roots (FR) and not on the amount of assimilates itself. This means that roots also grow through the winter when there is no assimilation due to low temperatures. There has been a discussion to change this behaviour and make root growth dependent on the assimilates send to the roots: so root growth stops when there are no assimilates available for growth.</p> <p>Finally, we decided not to change the root model and keep the original WOFOST approach because of the following reasons: - A dry top layer in the soil could create a large drought stress that reduces the   assimilates to zero. In this situation the roots would not grow if dependent on the   assimilates, while water is available in the zone just below the root zone. Therefore   a dependency on the amount of assimilates could create model instability in dry   conditions (e.g. Southern-Mediterranean, etc.). - Other solutions to alleviate the problem above were explored: only put this limitation   after a certain development stage, putting a dependency on soil moisture levels in the   unrooted soil compartment. All these solutions were found to introduce arbitrary   parameters that have no clear explanation. Therefore all proposed solutions were discarded.</p> <p>We conclude that our current knowledge on root development is insufficient to propose a better and more biophysical approach to root development in WOFOST.</p> <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>Initialize the model.</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Calculate the rates of change of the state variables.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate the state variables using the rates of change.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.initialize","title":"initialize","text":"<pre><code>initialize(day: date, kiosk: VariableKiosk, parvalues: ParameterProvider) -&gt; None\n</code></pre> <p>Initialize the model.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The starting date of the simulation.</p> </li> <li> <code>kiosk</code>               (<code>VariableKiosk</code>)           \u2013            <p>A container for registering and publishing (internal and external) state variables. See PCSE documentation for details.</p> </li> <li> <code>parvalues</code>               (<code>ParameterProvider</code>)           \u2013            <p>A dictionary-like container holding all parameter sets (crop, soil, site) as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/root_dynamics.py</code> <pre><code>def initialize(\n    self, day: datetime.date, kiosk: VariableKiosk, parvalues: ParameterProvider\n) -&gt; None:\n    \"\"\"Initialize the model.\n\n    Args:\n        day (datetime.date): The starting date of the simulation.\n        kiosk (VariableKiosk): A container for registering and publishing\n            (internal and external) state variables. See PCSE documentation for\n            details.\n        parvalues (ParameterProvider): A dictionary-like container holding\n            all parameter sets (crop, soil, site) as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    self.params = self.Parameters(parvalues)\n    self.rates = self.RateVariables(kiosk, publish=[\"DRRT\", \"GRRT\"])\n    self.kiosk = kiosk\n\n    # INITIAL STATES\n    params = self.params\n\n    # Initial root depth states\n    rdmax = torch.max(params.RDI, torch.min(params.RDMCR, params.RDMSOL))\n    RDM = rdmax\n    RD = params.RDI\n\n    # initial root biomass states\n    WRT = params.TDWI * self.kiosk.FR\n    DWRT = torch.tensor(0.0, dtype=DTYPE)\n    TWRT = WRT + DWRT\n\n    self.states = self.StateVariables(\n        kiosk, publish=[\"RD\", \"WRT\", \"TWRT\"], RD=RD, RDM=RDM, WRT=WRT, DWRT=DWRT, TWRT=TWRT\n    )\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day: date = None, drv: WeatherDataContainer = None) -&gt; None\n</code></pre> <p>Calculate the rates of change of the state variables.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>, default:                   <code>None</code> )           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>drv</code>               (<code>WeatherDataContainer</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary-like container holding weather data elements as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/root_dynamics.py</code> <pre><code>@prepare_rates\ndef calc_rates(self, day: datetime.date = None, drv: WeatherDataContainer = None) -&gt; None:\n    \"\"\"Calculate the rates of change of the state variables.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        drv (WeatherDataContainer, optional): A dictionary-like container holding\n            weather data elements as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    p = self.params\n    r = self.rates\n    s = self.states\n    k = self.kiosk\n\n    # If DVS &lt; 0, the crop has not yet emerged, so we zerofy the rates using mask\n    # Make a mask (0 if DVS &lt; 0, 1 if DVS &gt;= 0)\n    DVS = torch.as_tensor(k[\"DVS\"], dtype=DTYPE)\n    mask = (DVS &gt;= 0).to(dtype=DTYPE)\n\n    # Increase in root biomass\n    r.GRRT = mask * k.FR * k.DMI\n    r.DRRT = mask * s.WRT * p.RDRRTB(k.DVS)\n    r.GWRT = r.GRRT - r.DRRT\n\n    # Increase in root depth\n    r.RR = mask * torch.min((s.RDM - s.RD), p.RRI)\n\n    # Do not let the roots growth if partioning to the roots\n    # (variable FR) is zero.\n    FR = torch.as_tensor(k[\"FR\"], dtype=DTYPE)\n    mask = (FR &gt; 0.0).to(dtype=DTYPE)\n    r.RR = r.RR * mask\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.integrate","title":"integrate","text":"<pre><code>integrate(day: date = None, delt=1.0) -&gt; None\n</code></pre> <p>Integrate the state variables using the rates of change.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>, default:                   <code>None</code> )           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>delt</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The time step for integration. Defaults to 1.0.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/root_dynamics.py</code> <pre><code>@prepare_states\ndef integrate(self, day: datetime.date = None, delt=1.0) -&gt; None:\n    \"\"\"Integrate the state variables using the rates of change.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        delt (float, optional): The time step for integration. Defaults to 1.0.\n    \"\"\"\n    rates = self.rates\n    states = self.states\n\n    # Dry weight of living roots\n    states.WRT = states.WRT + rates.GWRT\n\n    # Dry weight of dead roots\n    states.DWRT = states.DWRT + rates.DRRT\n\n    # Total weight dry + living roots\n    states.TWRT = states.WRT + states.DWRT\n\n    # New root depth\n    states.RD = states.RD + rates.RR\n</code></pre>"},{"location":"api_reference/#utility-under-development","title":"Utility (under development)","text":""},{"location":"api_reference/#diffwofost.physical_models.utils.EngineTestHelper","title":"diffwofost.physical_models.utils.EngineTestHelper","text":"<pre><code>EngineTestHelper(parameterprovider, weatherdataprovider, agromanagement, test_config, external_states=None)\n</code></pre> <p>               Bases: <code>Engine</code></p> <p>An engine which is purely for running the YAML unit tests.</p> Source code in <code>src/diffwofost/physical_models/utils.py</code> <pre><code>def __init__(\n    self,\n    parameterprovider,\n    weatherdataprovider,\n    agromanagement,\n    test_config,\n    external_states=None,\n):\n    BaseEngine.__init__(self)\n\n    # Load the model configuration\n    self.mconf = ConfigurationLoader(test_config)\n    self.parameterprovider = parameterprovider\n\n    # Variable kiosk for registering and publishing variables\n    self.kiosk = VariableKioskTestHelper(external_states)\n\n    # Placeholder for variables to be saved during a model run\n    self._saved_output = list()\n    self._saved_summary_output = list()\n    self._saved_terminal_output = dict()\n\n    # register handlers for starting/finishing the crop simulation, for\n    # handling output and terminating the system\n    self._connect_signal(self._on_CROP_START, signal=signals.crop_start)\n    self._connect_signal(self._on_CROP_FINISH, signal=signals.crop_finish)\n    self._connect_signal(self._on_OUTPUT, signal=signals.output)\n    self._connect_signal(self._on_TERMINATE, signal=signals.terminate)\n\n    # Component for agromanagement\n    self.agromanager = self.mconf.AGROMANAGEMENT(self.kiosk, agromanagement)\n    start_date = self.agromanager.start_date\n    end_date = self.agromanager.end_date\n\n    # Timer: starting day, final day and model output\n    self.timer = Timer(self.kiosk, start_date, end_date, self.mconf)\n    self.day, delt = self.timer()\n    # Update external states in the kiosk\n    self.kiosk(self.day)\n\n    # Driving variables\n    self.weatherdataprovider = weatherdataprovider\n    self.drv = self._get_driving_variables(self.day)\n\n    # Component for simulation of soil processes\n    if self.mconf.SOIL is not None:\n        self.soil = self.mconf.SOIL(self.day, self.kiosk, parameterprovider)\n\n    # Call AgroManagement module for management actions at initialization\n    self.agromanager(self.day, self.drv)\n\n    # Calculate initial rates\n    self.calc_rates(self.day, self.drv)\n</code></pre>"},{"location":"citation/","title":"Citation","text":"<p>If you use this software, please cite it using the zenodo DOI: https://doi.org/10.5281/zenodo.17474960.</p>"},{"location":"developer_guide/","title":"Developer guide","text":"<p>If you are a developer wanting to contribute to the diffwofost package, this guide will help you get started. First check out the contribution guidelines in Contributing guide and the Project setup to get familiar with the package structure and development practices.</p>"},{"location":"developer_guide/#installation-in-development-mode","title":"Installation in development mode","text":"<p>To install the package in development mode, you need to clone the source code and install the package in development mode:</p> <pre><code>git clone https://github.com/WUR-AI/diffWOFOST.git\ncd diffWOFOST\npip install -e .[dev]  ## install with development dependencies\npip install -e .[docs]  ## install with documentation dependencies\n</code></pre>"},{"location":"developer_guide/#github-collaboration-workflow","title":"GitHub collaboration workflow","text":"<p>We use a GitHub collaboration workflow based on feature branches and pull requests. When starting adding a new feature or fixing a bug, create a new branch from <code>main</code> branch. When your changes are ready, create a pull request to merge your changes back into <code>main</code> branch. Make sure to ask for at least one review from another team member before merging your pull request.</p>"},{"location":"developer_guide/#running-the-tests","title":"Running the tests","text":"<ul> <li>Tests should be put in the <code>tests</code> folder.</li> <li>The testing framework used is PyTest</li> <li>The project uses GitHub action workflows   to automatically run tests on GitHub infrastructure against multiple Python   versions. Workflows can be found in <code>.github/workflows</code> directory.</li> <li>Relevant section in the   guide</li> <li>To run the tests locally, you need to make sure that you have installed the development dependencies as described in the Installation in development mode section. Then, inside the package directory, run:</li> </ul> <pre><code>pytest -v\n</code></pre> <p>to run all tests with verbose output. To run an individual test file, run:</p> <pre><code>pytest -v tests/test_my_module.py\n</code></pre>"},{"location":"developer_guide/#linters","title":"Linters","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n\n# check formatting only\nruff format --check . --diff\n</code></pre>"},{"location":"developer_guide/#documentation-page","title":"Documentation page","text":"<ul> <li>Documentation should be put in the <code>docs/</code> directory.</li> <li>We recommend writing the documentation using Google style docstrings.</li> <li>The documentation is set up with the MkDocs.</li> <li><code>.mkdocs.yml</code> is the MkDocs configuration file. When MkDocs is building the documentation this package and its development dependencies are installed so the API reference can be rendered.</li> <li>Make sure you have installed the documentation dependencies as described in the Installation in development mode section. Then, inside the package directory, run:</li> </ul> <pre><code># Build the documentation\nmkdocs build\n\n# Preview the documentation\nmkdocs serve\n</code></pre> <p>Click on the link provided in the terminal to view the documentation page.</p>"},{"location":"developer_guide/#coding-style-conventions-and-code-quality","title":"Coding style conventions and code quality","text":"<ul> <li>Relevant section in the NLeSC guide.</li> </ul>"},{"location":"developer_guide/#continuous-code-quality","title":"Continuous code quality","text":"<p>Sonarcloud is used to perform quality analysis and code coverage report</p> <ul> <li><code>sonar-project.properties</code> is the SonarCloud configuration file</li> <li><code>.github/workflows/sonarcloud.yml</code> is the GitHub action workflow which performs the SonarCloud analysis</li> </ul>"},{"location":"examples/","title":"Example notebooks","text":""},{"location":"examples/#optimization-with-diffwofost","title":"Optimization with diffWOFOST","text":"<p>We provide an example notebook showing optimization of models' parameters with <code>diffWOFOST</code>. To get familiar with the concepts and implementation, check out <code>Introduction</code> in the documentation.</p> Open the notebook Access the source View the notebook <p>Note</p> <p>When calculating gradients, it is important to ensure that the predicted physical parameters are within realistic bounds regarding the crop and environmental conditions.</p> <p>Also, when calculating gradients of an output w.r.t. parameters, it would be good to know in advance how the parameters in a model influence the outputs. If a parameter has little to no influence on an output, the gradient of the output w.r.t the parameter will be close to zero, which may not provide useful information for optimization.</p>"},{"location":"installation/","title":"Installation","text":"<p>To install the package, use pip:</p> <pre><code>pip install diffwofost\n</code></pre> <p>if you want to run notebooks locally, you need to install <code>jupyterlab</code>:</p> <pre><code>pip install jupyterlab\n</code></pre> <p>If you are a contributor, clone the source code and install the package in development mode:</p> <pre><code>git clone https://github.com/WUR-AI/diffWOFOST.git\ncd diffWOFOST\npip install -e .[dev]\n</code></pre> <p>If you are a contributor, follow the instructions in the <code>How to Contribute</code> in the documentation.</p>"},{"location":"license/","title":"License","text":"<p>EUPL, Version 1.1</p> <p>Licensed under the EUPL, Version 1.1 or as soon they will be approved by the European Commission - subsequent versions of the EUPL (the \"Licence\").</p> <p>You may not use this work except in compliance with the Licence. You may obtain a copy of the Licence at:</p> <p>https://interoperable-europe.ec.europa.eu/licence/european-union-public-licence-version-11-eupl Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p> <p>See the Licence for the specific language governing permissions and limitations under the Licence.</p>"},{"location":"project_setup/","title":"Project setup","text":"<p>Here we provide some details about the project setup. Most of the choices are explained in the Turing Way: Guide for Reproducible Research.</p>"},{"location":"project_setup/#repository-structure","title":"Repository structure","text":"<p>The repository has the following structure:</p> <pre><code>\u251c\u2500\u2500 .github/        # GitHub specific files such as workflows\n\u251c\u2500\u2500 docs/           # Documentation source files\n\u251c\u2500\u2500 my_package/     # Main package code\n\u251c\u2500\u2500 tests/          # Test code\n\u251c\u2500\u2500 .gitignore      # Git ignore file\n\u251c\u2500\u2500 CITATION.cff    # Citation file\n\u251c\u2500\u2500 LICENSE         # License file\n\u251c\u2500\u2500 README.md       # User documentation\n\u251c\u2500\u2500 pyproject.toml  # Project configuration file and dependencies\n\u251c\u2500\u2500 mkdocs.yml      # MkDocs configuration file\n</code></pre>"},{"location":"project_setup/#package-management-and-dependencies","title":"Package management and dependencies","text":"<p>You can use pip for installing dependencies and package management.</p> <ul> <li>Runtime dependencies should be added to <code>pyproject.toml</code> in the <code>dependencies</code>   list under <code>[project]</code>.</li> <li>Development dependencies, such as for testing or documentation, should be   added to <code>pyproject.toml</code> in one of the lists under   <code>[project.optional-dependencies]</code>.</li> </ul>"},{"location":"project_setup/#packagingone-command-install","title":"Packaging/One command install","text":"<p>You can distribute your code using PyPI. This can be done automatically using GitHub workflows, see <code>.github/</code>.</p>"},{"location":"project_setup/#package-version-number","title":"Package version number","text":"<ul> <li>We recommend using semantic versioning.</li> <li>For convenience, the package version is stored in a single place: <code>pyproject.toml</code>.</li> <li>Don't forget to update the version number before making a release! Also, update <code>__version__</code> variable in <code>diffwofost/__init__.py</code> to the    same version.</li> </ul>"},{"location":"project_setup/#citationcff","title":"CITATION.cff","text":"<ul> <li>To allow others to cite your software, add a <code>CITATION.cff</code> file</li> <li>It only makes sense to do this once there is something to cite (e.g., a software release with a DOI).</li> <li>Follow the Software Citation with CITATION.cff section in the Turing Way guide.</li> </ul>"},{"location":"project_setup/#code_of_conductmd","title":"CODE_OF_CONDUCT.md","text":"<ul> <li>Information about how to behave professionally</li> <li>To know more, read Turing Way guide on Code of Conduct</li> </ul>"},{"location":"project_setup/#contributingmd","title":"CONTRIBUTING.md","text":"<ul> <li>Information about how to contribute to this software package</li> <li>To know more, read Turing Way guide on Contributing</li> </ul>"},{"location":"references/","title":"References","text":"<p>Here are some useful references related to <code>WOFOST</code> and <code>PCSE</code>. If you want to cite the <code>diffWOFOST</code> package in your research, please use the software doi.</p> <ul> <li>WOFOST (WOrld FOod STudies)</li> <li>A gentle introduction to WOFOST</li> <li>PCSE/ WOFOST documentation</li> <li>Jupyter notebooks demonstrating the use of PCSE/WOFOST</li> <li>PCSE GitHub repository</li> <li>DeltaCrop project</li> </ul>"},{"location":"run_model/","title":"How to run a model","text":""},{"location":"run_model/#how-to-run-a-model-with-pcse","title":"How to run a model with PCSE","text":"<p>To get familiar with WOFOST models and how to run the models, we recommend to first check out the PCSE documentation and explore the notebooks 01 Getting Started with PCSE.ipynb and 02 Running with custom input data.ipynb .</p> <p>In a nutshell, we can run a model, for example, <code>leaf_dynamics</code> using diffWOFOST as:</p> <pre><code>from diffwofost.physical_models.utils import EngineTestHelper\n\n# create the model\nmodel = EngineTestHelper(\n    crop_parameters_provider,  # this provides the crop parameters\n    weather_data_provider,\n    agromanagement_provider,\n    leaf_dynamics_config_file,  # this where the differentiable model is specified\n    external_states,  # any external states if needed\n)\n\n# run the simulation with a fixed time step of one day\nmodel.run_till_terminate()\n\n# get the output\nresults = model.get_output()\n</code></pre>"},{"location":"notebooks/optimization/","title":"Optimization","text":"Optimizing parameters in a WOFOST crop model using <code>diffWOFOST</code> <p>This Jupyter notebook demonstrates the optimization of parameters in a differentiable model using the <code>diffwofost</code> package. The package provides differentiable implementations of the WOFOST model and its associated sub-models. As <code>diffwofost</code> is under active development, this notebook focuses on two sub-models: <code>leaf_dynamics</code> and <code>root_dynamics</code>.</p> <p>To enable these models to operate independently, certain state variables required by the model are supplied as \"external states\" derived from the test data. Also, at this stage, only a limited subset of model parameters has been made differentiable.</p> <p>The notebook is organized into two standalone sections that can be executed independently:</p> <ol> <li>Leaf Dynamics</li> <li>Root Dynamics</li> </ol> In\u00a0[\u00a0]: Copied! <pre># install diffwofost\n!pip install diffwofost\n</pre> # install diffwofost !pip install diffwofost In\u00a0[1]: Copied! <pre># ---- import libraries ----\nimport copy\nimport torch\nimport numpy\nimport yaml\nfrom pathlib import Path\nfrom diffwofost.physical_models.utils import EngineTestHelper\nfrom diffwofost.physical_models.utils import prepare_engine_input\n</pre> # ---- import libraries ---- import copy import torch import numpy import yaml from pathlib import Path from diffwofost.physical_models.utils import EngineTestHelper from diffwofost.physical_models.utils import prepare_engine_input In\u00a0[2]: Copied! <pre># ---- disable a warning: this will be fixed in the future ----\nimport warnings\nwarnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\")\n</pre> # ---- disable a warning: this will be fixed in the future ---- import warnings warnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\") In\u00a0[8]: Copied! <pre>import urllib.request\n\nurl = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_leafdynamics_wofost72_01.yaml\"\nfilename = \"test_leafdynamics_wofost72_01.yaml\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> import urllib.request  url = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_leafdynamics_wofost72_01.yaml\" filename = \"test_leafdynamics_wofost72_01.yaml\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: test_leafdynamics_wofost72_01.yaml\n</pre> <p>We also need to download a config file to be able to run each crop module. This will change in the future versions. To donwload the config file, you can use the following command:</p> In\u00a0[9]: Copied! <pre>url = \"https://raw.githubusercontent.com/WUR-AI/diffWOFOST/refs/heads/main/tests/physical_models/test_data/WOFOST_Leaf_Dynamics.conf\"\nfilename = \"WOFOST_Leaf_Dynamics.conf\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> url = \"https://raw.githubusercontent.com/WUR-AI/diffWOFOST/refs/heads/main/tests/physical_models/test_data/WOFOST_Leaf_Dynamics.conf\" filename = \"WOFOST_Leaf_Dynamics.conf\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: WOFOST_Leaf_Dynamics.conf\n</pre> In\u00a0[\u00a0]: Copied! <pre># ---- Check the path to the files that are downloaded as explained above ----\ntest_data_path = \"test_leafdynamics_wofost72_01.yaml\"\nconfig_path = \"WOFOST_Leaf_Dynamics.conf\"\n</pre> # ---- Check the path to the files that are downloaded as explained above ---- test_data_path = \"test_leafdynamics_wofost72_01.yaml\" config_path = \"WOFOST_Leaf_Dynamics.conf\" In\u00a0[4]: Copied! <pre># ---- Here we read the test data and set some variables ----\n(crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (\n    prepare_engine_input(test_data_path, [\"SPAN\", \"TDWI\", \"TBASE\", \"PERDL\", \"RGRLAI\"])\n)\n\nexpected_results = yaml.safe_load(open(test_data_path))[\"ModelResults\"]\nexpected_lai_twlv = torch.tensor(\n    [[float(item[\"LAI\"]), float(item[\"TWLV\"])] for item in expected_results], dtype=torch.float32\n).unsqueeze(0) # shape: [1, time_steps, 2]\n\n# ---- dont change this: in this config file we specified the diffrentiable version of leaf_dynamics ----\nconfig_path = str(Path(config_path).resolve()) \n</pre> # ---- Here we read the test data and set some variables ---- (crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (     prepare_engine_input(test_data_path, [\"SPAN\", \"TDWI\", \"TBASE\", \"PERDL\", \"RGRLAI\"]) )  expected_results = yaml.safe_load(open(test_data_path))[\"ModelResults\"] expected_lai_twlv = torch.tensor(     [[float(item[\"LAI\"]), float(item[\"TWLV\"])] for item in expected_results], dtype=torch.float32 ).unsqueeze(0) # shape: [1, time_steps, 2]  # ---- dont change this: in this config file we specified the diffrentiable version of leaf_dynamics ---- config_path = str(Path(config_path).resolve())  In\u00a0[5]: Copied! <pre># ---- Adjust the values if needed  ----\nTDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.40)\nSPAN_MIN, SPAN_MAX, SPAN_INIT = (10.0, 60.0, 30.0)\n\n# ---- Helper for bounded parameters ----\nclass BoundedParameter(torch.nn.Module):\n    def __init__(self, low, high, init_value):\n        super().__init__()\n        self.low = low\n        self.high = high\n\n        # Normalize to [0, 1]\n        init_norm = (init_value - low) / (high - low)\n\n        # Parameter in raw logit space\n        self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))\n\n    def forward(self):\n        return self.low + (self.high - self.low) * torch.sigmoid(self.raw)\n</pre> # ---- Adjust the values if needed  ---- TDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.40) SPAN_MIN, SPAN_MAX, SPAN_INIT = (10.0, 60.0, 30.0)  # ---- Helper for bounded parameters ---- class BoundedParameter(torch.nn.Module):     def __init__(self, low, high, init_value):         super().__init__()         self.low = low         self.high = high          # Normalize to [0, 1]         init_norm = (init_value - low) / (high - low)          # Parameter in raw logit space         self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))      def forward(self):         return self.low + (self.high - self.low) * torch.sigmoid(self.raw)  <p>Another helper class is <code>OptDiffLeafDynamics</code> which is a subclass of <code>torch.nn.Module</code>. We use this class to wrap the <code>EngineTestHelper</code> function and make it easier to run the model <code>leaf_dynamic</code>.</p> In\u00a0[6]: Copied! <pre># ---- Wrap the model with torch.nn.Module----\nclass OptDiffLeafDynamics(torch.nn.Module):\n    def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, config_path, external_states):\n        super().__init__()\n        self.crop_model_params_provider = crop_model_params_provider\n        self.weather_data_provider = weather_data_provider\n        self.agro_management_inputs = agro_management_inputs\n        self.config_path = config_path\n        self.external_states = external_states\n\n        # bounded parameters\n        self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)\n        self.span = BoundedParameter(SPAN_MIN, SPAN_MAX, init_value=SPAN_INIT)\n\n    def forward(self):\n        # currently, copying is needed due to an internal issue in engine\n        crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)\n        external_states_ = copy.deepcopy(self.external_states)\n        \n        tdwi_val = self.tdwi()\n        span_val = self.span()\n        \n        # pass new value of parameters to the model\n        crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)\n        crop_model_params_provider_.set_override(\"SPAN\", span_val, check=False)\n\n        engine = EngineTestHelper(\n            crop_model_params_provider_,\n            self.weather_data_provider,\n            self.agro_management_inputs,\n            self.config_path,\n            external_states_,\n        )\n        engine.run_till_terminate()\n        results = engine.get_output()\n        \n        return torch.stack(\n            [torch.stack([item[\"LAI\"], item[\"TWLV\"]]) for item in results]\n        ).unsqueeze(0) # shape: [1, time_steps, 2]\n</pre> # ---- Wrap the model with torch.nn.Module---- class OptDiffLeafDynamics(torch.nn.Module):     def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, config_path, external_states):         super().__init__()         self.crop_model_params_provider = crop_model_params_provider         self.weather_data_provider = weather_data_provider         self.agro_management_inputs = agro_management_inputs         self.config_path = config_path         self.external_states = external_states          # bounded parameters         self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)         self.span = BoundedParameter(SPAN_MIN, SPAN_MAX, init_value=SPAN_INIT)      def forward(self):         # currently, copying is needed due to an internal issue in engine         crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)         external_states_ = copy.deepcopy(self.external_states)                  tdwi_val = self.tdwi()         span_val = self.span()                  # pass new value of parameters to the model         crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)         crop_model_params_provider_.set_override(\"SPAN\", span_val, check=False)          engine = EngineTestHelper(             crop_model_params_provider_,             self.weather_data_provider,             self.agro_management_inputs,             self.config_path,             external_states_,         )         engine.run_till_terminate()         results = engine.get_output()                  return torch.stack(             [torch.stack([item[\"LAI\"], item[\"TWLV\"]]) for item in results]         ).unsqueeze(0) # shape: [1, time_steps, 2] In\u00a0[7]: Copied! <pre># ----  Create model ---- \nopt_model = OptDiffLeafDynamics(\n    crop_model_params_provider,\n    weather_data_provider,\n    agro_management_inputs,\n    config_path,\n    external_states,\n)\n\n# ----  Optimizer ---- \noptimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)\n\n# ----  We use relative MAE as loss because there are two outputs with different untis ----  \ndenom = torch.mean(torch.abs(expected_lai_twlv), dim=1) \n\n# Training loop (example)\nfor step in range(101):\n    optimizer.zero_grad()\n    results = opt_model() \n    mae = torch.mean(torch.abs(results - expected_lai_twlv), dim=1)\n    rmae = mae / denom\n    loss = rmae.sum()  # example: relative mean absolute error\n    loss.backward()\n    optimizer.step()\n\n    if step % 10 == 0:\n        print(f\"Step {step}, Loss {loss.item():.4f}, TDWI {opt_model.tdwi().item():.4f}, SPAN {opt_model.span().item():.4f}\")\n</pre> # ----  Create model ----  opt_model = OptDiffLeafDynamics(     crop_model_params_provider,     weather_data_provider,     agro_management_inputs,     config_path,     external_states, )  # ----  Optimizer ----  optimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)  # ----  We use relative MAE as loss because there are two outputs with different untis ----   denom = torch.mean(torch.abs(expected_lai_twlv), dim=1)   # Training loop (example) for step in range(101):     optimizer.zero_grad()     results = opt_model()      mae = torch.mean(torch.abs(results - expected_lai_twlv), dim=1)     rmae = mae / denom     loss = rmae.sum()  # example: relative mean absolute error     loss.backward()     optimizer.step()      if step % 10 == 0:         print(f\"Step {step}, Loss {loss.item():.4f}, TDWI {opt_model.tdwi().item():.4f}, SPAN {opt_model.span().item():.4f}\") <pre>Step 0, Loss 0.1348, TDWI 0.4242, SPAN 31.2111\nStep 10, Loss 0.0589, TDWI 0.4890, SPAN 36.7883\nStep 20, Loss 0.0174, TDWI 0.5191, SPAN 34.8344\nStep 30, Loss 0.0113, TDWI 0.5056, SPAN 35.0567\nStep 40, Loss 0.0067, TDWI 0.5100, SPAN 35.4831\nStep 50, Loss 0.0121, TDWI 0.5019, SPAN 34.6534\nStep 60, Loss 0.0005, TDWI 0.5038, SPAN 34.6887\nStep 70, Loss 0.0079, TDWI 0.5015, SPAN 35.7478\nStep 80, Loss 0.0145, TDWI 0.5061, SPAN 34.5574\nStep 90, Loss 0.0110, TDWI 0.4985, SPAN 34.3927\nStep 100, Loss 0.0271, TDWI 0.5064, SPAN 36.3026\n</pre> In\u00a0[11]: Copied! <pre># ---- validate the results using test data ---- \nprint(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}, SPAN {crop_model_params_provider[\"SPAN\"].item():.4f}\")\n</pre> # ---- validate the results using test data ----  print(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}, SPAN {crop_model_params_provider[\"SPAN\"].item():.4f}\") <pre>Actual TDWI 0.5100, SPAN 35.0000\n</pre> In\u00a0[1]: Copied! <pre># ---- import libraries ----\nimport copy\nimport torch\nimport numpy\nimport yaml\nfrom pathlib import Path\nfrom diffwofost.physical_models.utils import EngineTestHelper\nfrom diffwofost.physical_models.utils import prepare_engine_input\n</pre> # ---- import libraries ---- import copy import torch import numpy import yaml from pathlib import Path from diffwofost.physical_models.utils import EngineTestHelper from diffwofost.physical_models.utils import prepare_engine_input In\u00a0[2]: Copied! <pre># ---- disable a warning: this will be fixed in the future ----\nimport warnings\nwarnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\")\n</pre> # ---- disable a warning: this will be fixed in the future ---- import warnings warnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\") In\u00a0[11]: Copied! <pre>import urllib.request\n\nurl = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_rootdynamics_wofost72_01.yaml\"\nfilename = \"test_rootdynamics_wofost72_01.yaml\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> import urllib.request  url = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_rootdynamics_wofost72_01.yaml\" filename = \"test_rootdynamics_wofost72_01.yaml\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: test_rootdynamics_wofost72_01.yaml\n</pre> <p>We also need to download a config file to be able to run each crop module. This will change in the future versions. To donwload the config file, you can use the following command:</p> In\u00a0[12]: Copied! <pre>url = \"https://raw.githubusercontent.com/WUR-AI/diffWOFOST/refs/heads/main/tests/physical_models/test_data/WOFOST_Root_Dynamics.conf\"\nfilename = \"WOFOST_Root_Dynamics.conf\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> url = \"https://raw.githubusercontent.com/WUR-AI/diffWOFOST/refs/heads/main/tests/physical_models/test_data/WOFOST_Root_Dynamics.conf\" filename = \"WOFOST_Root_Dynamics.conf\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: WOFOST_Root_Dynamics.conf\n</pre> In\u00a0[3]: Copied! <pre># ---- Check the path to the files that are downloaded as explained above ----\ntest_data_path = \"test_rootdynamics_wofost72_01.yaml\"\nconfig_path = \"WOFOST_Root_Dynamics.conf\"\n</pre> # ---- Check the path to the files that are downloaded as explained above ---- test_data_path = \"test_rootdynamics_wofost72_01.yaml\" config_path = \"WOFOST_Root_Dynamics.conf\" In\u00a0[4]: Copied! <pre># ---- Here we read the test data and set some variables ----\n(crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (\n    prepare_engine_input(test_data_path, [\"RDI\", \"RRI\", \"RDMCR\", \"RDMSOL\", \"TDWI\", \"IAIRDU\"])\n)\n\nexpected_results = yaml.safe_load(open(test_data_path))[\"ModelResults\"]\nexpected_twrt = torch.tensor(\n    [float(item[\"TWRT\"]) for item in expected_results], dtype=torch.float32\n) # shape: [1, time_steps]\n\n# ---- dont change this: in this config file we specified the diffrentiable version of root_dynamics ----\nconfig_path = str(Path(config_path).resolve()) \n</pre> # ---- Here we read the test data and set some variables ---- (crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (     prepare_engine_input(test_data_path, [\"RDI\", \"RRI\", \"RDMCR\", \"RDMSOL\", \"TDWI\", \"IAIRDU\"]) )  expected_results = yaml.safe_load(open(test_data_path))[\"ModelResults\"] expected_twrt = torch.tensor(     [float(item[\"TWRT\"]) for item in expected_results], dtype=torch.float32 ) # shape: [1, time_steps]  # ---- dont change this: in this config file we specified the diffrentiable version of root_dynamics ---- config_path = str(Path(config_path).resolve())  In\u00a0[5]: Copied! <pre># ---- Adjust the values if needed  ----\nTDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.30)\n\n# ---- Helper for bounded parameters ----\nclass BoundedParameter(torch.nn.Module):\n    def __init__(self, low, high, init_value):\n        super().__init__()\n        self.low = low\n        self.high = high\n\n        # Normalize to [0, 1]\n        init_norm = (init_value - low) / (high - low)\n\n        # Parameter in raw logit space\n        self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))\n\n    def forward(self):\n        return self.low + (self.high - self.low) * torch.sigmoid(self.raw)\n</pre> # ---- Adjust the values if needed  ---- TDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.30)  # ---- Helper for bounded parameters ---- class BoundedParameter(torch.nn.Module):     def __init__(self, low, high, init_value):         super().__init__()         self.low = low         self.high = high          # Normalize to [0, 1]         init_norm = (init_value - low) / (high - low)          # Parameter in raw logit space         self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))      def forward(self):         return self.low + (self.high - self.low) * torch.sigmoid(self.raw)  <p>Another helper class is <code>OptRootLeafDynamics</code> which is a subclass of <code>torch.nn.Module</code>. We use this class to wrap the <code>EngineTestHelper</code> function and make it easier to run the model <code>root_dynamic</code>.</p> In\u00a0[6]: Copied! <pre># ---- Wrap the model with torch.nn.Module----\nclass OptDiffRootDynamics(torch.nn.Module):\n    def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, config_path, external_states):\n        super().__init__()\n        self.crop_model_params_provider = crop_model_params_provider\n        self.weather_data_provider = weather_data_provider\n        self.agro_management_inputs = agro_management_inputs\n        self.config_path = config_path\n        self.external_states = external_states\n\n        # bounded parameters\n        self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)\n        \n    def forward(self):\n        # currently, copying is needed due to an internal issue in engine\n        crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)\n        external_states_ = copy.deepcopy(self.external_states)\n        \n        tdwi_val = self.tdwi()\n        \n        # pass new value of parameters to the model\n        crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)\n\n        engine = EngineTestHelper(\n            crop_model_params_provider_,\n            self.weather_data_provider,\n            self.agro_management_inputs,\n            self.config_path,\n            external_states_,\n        )\n        engine.run_till_terminate()\n        results = engine.get_output()\n        \n        return torch.stack([item[\"TWRT\"] for item in results]) # shape: [1, time_steps]\n</pre> # ---- Wrap the model with torch.nn.Module---- class OptDiffRootDynamics(torch.nn.Module):     def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, config_path, external_states):         super().__init__()         self.crop_model_params_provider = crop_model_params_provider         self.weather_data_provider = weather_data_provider         self.agro_management_inputs = agro_management_inputs         self.config_path = config_path         self.external_states = external_states          # bounded parameters         self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)              def forward(self):         # currently, copying is needed due to an internal issue in engine         crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)         external_states_ = copy.deepcopy(self.external_states)                  tdwi_val = self.tdwi()                  # pass new value of parameters to the model         crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)          engine = EngineTestHelper(             crop_model_params_provider_,             self.weather_data_provider,             self.agro_management_inputs,             self.config_path,             external_states_,         )         engine.run_till_terminate()         results = engine.get_output()                  return torch.stack([item[\"TWRT\"] for item in results]) # shape: [1, time_steps] In\u00a0[7]: Copied! <pre># ----  Create model ---- \nopt_model = OptDiffRootDynamics(\n    crop_model_params_provider,\n    weather_data_provider,\n    agro_management_inputs,\n    config_path,\n    external_states,\n)\n</pre> # ----  Create model ----  opt_model = OptDiffRootDynamics(     crop_model_params_provider,     weather_data_provider,     agro_management_inputs,     config_path,     external_states, ) In\u00a0[12]: Copied! <pre># ----  Optimizer ---- \noptimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)\n\n# ----  We use relative MAE as loss because there are two outputs with different untis ----  \ndenom = torch.mean(torch.abs(expected_twrt)) \n\n# Training loop (example)\nfor step in range(101):\n    optimizer.zero_grad()\n    results = opt_model() \n    mae = torch.mean(torch.abs(results - expected_twrt))\n    loss = mae / denom # example: relative mean absolute error\n    loss.backward()\n    optimizer.step()\n\n    if step % 10 == 0:\n        print(f\"Step {step}, Loss {loss.item():.8f}, TDWI {opt_model.tdwi().item():.4f}\")\n</pre> # ----  Optimizer ----  optimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)  # ----  We use relative MAE as loss because there are two outputs with different untis ----   denom = torch.mean(torch.abs(expected_twrt))   # Training loop (example) for step in range(101):     optimizer.zero_grad()     results = opt_model()      mae = torch.mean(torch.abs(results - expected_twrt))     loss = mae / denom # example: relative mean absolute error     loss.backward()     optimizer.step()      if step % 10 == 0:         print(f\"Step {step}, Loss {loss.item():.8f}, TDWI {opt_model.tdwi().item():.4f}\") <pre>Step 0, Loss 0.00000021, TDWI 0.5340\nStep 10, Loss 0.00000015, TDWI 0.5137\nStep 20, Loss 0.00000164, TDWI 0.5144\nStep 30, Loss 0.00000068, TDWI 0.5107\nStep 40, Loss 0.00000019, TDWI 0.5072\nStep 50, Loss 0.00000080, TDWI 0.5084\nStep 60, Loss 0.00000007, TDWI 0.5071\nStep 70, Loss 0.00000100, TDWI 0.5091\nStep 80, Loss 0.00000131, TDWI 0.5089\nStep 90, Loss 0.00000068, TDWI 0.5115\nStep 100, Loss 0.00000071, TDWI 0.5053\n</pre> In\u00a0[11]: Copied! <pre># ---- validate the results using test data ---- \nprint(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}\")\n</pre> # ---- validate the results using test data ----  print(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}\") <pre>Actual TDWI 0.5100\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/optimization/#1-leaf-dynamics","title":"1. Leaf dynamics\u00b6","text":"<p>In this section, we will demonstrate how to optimize two parameters <code>TWDI</code> and <code>SPAN</code> in leaf_dynamics model using a differentiable version of leaf_dynamics. The optimization will be done using the Adam optimizer from <code>torch.optim</code>.</p>"},{"location":"notebooks/optimization/#11-software-requirements","title":"1.1 software requirements\u00b6","text":"<p>To run this notebook, we need to install the <code>diffwofost</code>; the differentiable version of WOFOST models. Since the package is constantly under development, make sure you have the latest version of <code>diffwofost</code> installed in your python environment. You can install it using pip:</p>"},{"location":"notebooks/optimization/#12-data","title":"1.2. Data\u00b6","text":"<p>A test dataset of <code>LAI</code> (Leaf area index, including stem and pod area) and <code>TWLV</code> (Dry weight of total leaves (living + dead)) will be used to optimize parametesr <code>TWDI</code> (total initial dry weight) and <code>SPAN</code> (life span of leaves). Note that in leaf_dynamic, changes in <code>SPAN</code> dont affect <code>TWLV</code>.</p> <p>The data is stored in PCSE tests folder, and can be doewnloded from PCSE repsository. You can select any of the files related to <code>leaf_dynamics</code> model with a file name that follwos the pattern <code>test_leafdynamics_wofost72_*.yaml</code>. Each file contains different data depending on the locatin and crop type. For example, you can download the file \"test_leafdynamics_wofost72_01.yaml\" as:</p>"},{"location":"notebooks/optimization/#13-helper-classesfunctions","title":"1.3. Helper classes/functions\u00b6","text":"<p>The model parameters shoudl stay in a valid range. To ensure this, we will use <code>BoundedParameter</code> class with (min, max) and initial values for each parameter. You might change these values depending on the crop type and location. But dont use a very small range, otherwise gradiants will be very small and the optimization will be very slow.</p>"},{"location":"notebooks/optimization/#2-root-dynamics","title":"2. Root dynamics\u00b6","text":"<p>In this section, we will demonstrate how to optimize two parameters <code>TWDI</code> in root_dynamics model using a differentiable version of root_dynamics. The optimization will be done using the Adam optimizer from <code>torch.optim</code>.</p>"},{"location":"notebooks/optimization/#21-software-requirements","title":"2.1 software requirements\u00b6","text":"<p>To run this notebook, we need to install the <code>diffwofost</code>; the differentiable version of WOFOST models. Since the package is constantly under development, make sure you have the latest version of <code>diffwofost</code> installed in your python environment. You can install it using pip:</p> <pre>pip install diffwofost\n</pre>"},{"location":"notebooks/optimization/#22-data","title":"2.2. Data\u00b6","text":"<p>A test dataset of <code>TWRT</code> (Total weight of roots) will be used to optimize parametesr <code>TWDI</code> (total initial dry weight). Note that in root_dynamic, changes in <code>TWDI</code> dont affect <code>RD</code> (Current rooting depth).</p> <p>The data is stored in PCSE tests folder, and can be doewnloded from PCSE repsository. You can select any of the files related to <code>root_dynamics</code> model with a file name that follwos the pattern <code>test_rootdynamics_wofost72_*.yaml</code>. Each file contains different data depending on the locatin and crop type. For example, you can download the file \"test_rootdynamics_wofost72_01.yaml\" as:</p>"},{"location":"notebooks/optimization/#23-helper-classesfunctions","title":"2.3. Helper classes/functions\u00b6","text":"<p>The model parameters shoudl stay in a valid range. To ensure this, we will use <code>BoundedParameter</code> class with (min, max) and initial values for each parameter. You might change these values depending on the crop type and location. But dont use a very small range, otherwise gradiants will be very small and the optimization will be very slow.</p>"}]}