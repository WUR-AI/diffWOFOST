{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"diffWOFOST","text":""},{"location":"#diffwofost-differentiable-wofost","title":"diffWOFOST: Differentiable WOFOST","text":"<p>The package diffWOFOST contains a differentiable implementation of the WOFOST crop growth models using <code>pytorch</code> and <code>PCSE</code>. The implementation allows for automatic differentiation, enabling gradient-based optimization, sensitivity analysis and data assimilation.</p> <p>In PCSE, WOFOST models are categorized based on <code>version, productionlevel, waterbalance, nitrogenbalance</code> and each model contains a set of elements e.g. crop and soil models, see models available in PCSE and PCSE Engine.</p> <p>In diffWOFOST, each element is implemented as a differentiable module, using torch.Tensor, allowing for end-to-end differentiation of the entire WOFOST model. To develop a differentiable module, we check for look-up tables, hard thresholds, and mathematical operations, and replace them with differentiable alternatives.</p> <p>In addition to differentiability, the implementation also focuses on efficiency, by leveraging vectorized operations. This is particularly important for large-scale simulations and training workflows, where the computational cost can be significant.</p>"},{"location":"#hybrid-modelling-with-diffwofost","title":"Hybrid modelling with diffWOFOST","text":"<p>Hybrid modelling, referring to a combination of process-based and machine-learning modelling, has recently emerged as a promising line of research to harness the strengths of both approaches while mitigating their respective weaknesses, see Integrating Scientific Knowledge with Machine Learning for Engineering and Environmental Systems and Deep learning and process understanding for data-driven Earth system science.</p> <p>The approach where an machine learning (ML) model predicts physical parameters, which are then used in a physics-based model, and combines both in a hybrid architecture, is a state-of-the-art approach and is known under various names, see Scientific Machine Learning. The mathematics would be:</p> \\[ \\frac{\\partial \\text{loss}}{\\partial \\text{(ML model weights)}} = \\frac{\\partial \\text{loss}}{\\partial \\text{(physics-based model output)}} \\cdot \\frac{\\partial \\text{(physics-based model output)}}{\\partial \\text{(physics-based model parameters)}} \\cdot \\frac{\\partial \\text{(physics-based model parameters)}}{\\partial \\text{(ML model weights)}} \\] <p>And code wise, this would look like:</p> <pre><code>import torch.nn as nn\n\n# Step 1: ML model that outputs physical parameters e.g. LSTM\nclass MLModel(nn.Module):\n    def __init__(self, input_size, hidden_size, num_physical_params):\n        super().__init__()\n        self.lstm = nn.LSTM(input_size=input_size, hidden_size=hidden_size, batch_first=True)\n        self.linear = nn.Linear(hidden_size, num_physical_params)\n\n    def forward(self, x):\n        lstm_out, _ = self.lstm(x)\n        physical_params = self.linear(lstm_out[:, -1, :])\n        return physical_params\n\n# Step 2: Physical model i.e. a differentiable WOFOST model e.g. Wofost72_PP\nclass PhysicalModel(nn.Module):\n    def __init__(self, dt):\n        super().__init__()\n\n    def forward(self, params):\n        model = Wofost72_PP(params, ...)  # this is differentiable version\n        model.run_till_terminate()  # finish the simulation\n        output = model.get_output()\n        return output\n\n# Step 3: Hybrid model integrating ML and physical model\nclass HybridModel(nn.Module):\n    def __init__(self, input_size, hidden_size, num_physical_params):\n        super().__init__()\n        self.ml_model = MLModel(input_size, hidden_size, num_physical_params)\n        self.physical_model = PhysicalModel()\n\n    def forward(self, x):\n        physical_params = self.ml_model(x)\n        output = self.physical_model(physical_params)\n        return output, physical_params\n</code></pre>"},{"location":"#code-structure-under-development","title":"Code structure (under development)","text":"<p>The package is structured as follows:</p> <pre><code>\u251c\u2500\u2500 physical_models/\n        \u251c\u2500\u2500 crop/  # differentiable implementation of each crop model\n        \u2502   \u251c\u2500\u2500 leaf_dynamics.py\n        \u2502   \u251c\u2500\u2500 root_dynamics.py\n        \u2502   \u251c\u2500\u2500 ...\n        \u251c\u2500\u2500 soil/\n        \u251c\u2500\u2500 utils.py  # helpers\n</code></pre> <p>Note</p> <p>At the moment the package is under continuous development. So make sure that you install the latest version.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [...]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p>"},{"location":"CONTRIBUTING/","title":"Contributing guide","text":"<p>We welcome any kind of contribution to our software, from simple comment or question to a full fledged pull request. Please read and follow our Code of Conduct.</p> <p>A contribution can be one of the following cases:</p> <ol> <li>you have a question;</li> <li>you think you may have found a bug (including unexpected behavior);</li> <li>you want to make some kind of change to the code base (e.g. to fix a bug, to add a new feature, to update documentation);</li> <li>you want to make a new release of the code base.</li> </ol> <p>The sections below outline the steps in each case.</p>"},{"location":"CONTRIBUTING/#you-have-a-question","title":"You have a question","text":"<ol> <li>use the search functionality in    issues to see if someone    already filed the same issue;</li> <li>if your issue search did not yield any relevant results, make a new issue;</li> <li>apply the \"Question\" label; apply other labels when relevant.</li> </ol>"},{"location":"CONTRIBUTING/#you-think-you-may-have-found-a-bug","title":"You think you may have found a bug","text":"<ol> <li>use the search functionality in    issues to see if someone    already filed the same issue;</li> <li>if your issue search did not yield any relevant results, make a new issue,    making sure to provide enough information to the rest of the community to    understand the cause and context of the problem.</li> </ol>"},{"location":"CONTRIBUTING/#you-want-to-make-some-kind-of-change-to-the-code-base","title":"You want to make some kind of change to the code base","text":"<ol> <li>(important) announce your plan to the rest of the community before you    start working. This announcement should be in the form of a (new) issue;</li> <li>(important) wait until some kind of consensus is reached about your idea being a good idea;</li> <li>follow the instruction in developer_guide.md.</li> </ol> <p>In case you feel like you've made a valuable contribution, but you don't know how to write or run tests for it, or how to generate the documentation: don't let this discourage you from making the pull request; we can help you! Just go ahead and submit an issue and ask your questions.</p>"},{"location":"CONTRIBUTING/#you-want-to-make-a-new-release-of-the-code-base","title":"You want to make a new release of the code base","text":"<p>To create a release you need write permission on the repository.</p> <ol> <li>Check the author list in <code>CITATION.cff</code>in    the root of the repository.</li> <li>Bump the version. The version can be manually changed in <code>pyproject.toml</code> in    the root of the repository. Follow Semantic Versioning    principles. Also, update <code>__version__</code> variable in <code>diffwofost/__init__.py</code> to the    same version.</li> <li>Go to the GitHub release    page. Press draft a new    release button. Fill version, title and description field. Press the Publish    Release button. For this package, the zenodo integration is enabled, so a new    DOI will be created automatically.</li> <li>This software automatically publish to PyPI using a release or publish    workflow. Wait until PyPi publish    workflow    has completed and verify new release is on    PyPi</li> </ol>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>The package <code>diffWOFOST</code> is developed in the DeltaCrop project, a collaboration between Wageningen University &amp; Research and Netherlands eScience Center.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#crop-modules","title":"Crop modules","text":""},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology","title":"diffwofost.physical_models.crop.phenology.DVS_Phenology","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Implements the algorithms for phenologic development in WOFOST.</p> <p>Phenologic development in WOFOST is expresses using a unitless scale which takes the values 0 at emergence, 1 at Anthesis (flowering) and 2 at maturity. This type of phenological development is mainly representative for cereal crops. All other crops that are simulated with WOFOST are forced into this scheme as well, although this may not be appropriate for all crops. For example, for potatoes development stage 1 represents the start of tuber formation rather than flowering.</p> <p>Phenological development is mainly governed by temperature and can be modified by the effects of day length and vernalization during the period before Anthesis. After Anthesis, only temperature influences the development rate.</p> <p>Simulation parameters</p> Name Description Type Unit TSUMEM Temperature sum from sowing to emergence SCr TBASEM Base temperature for emergence SCr TEFFMX Maximum effective temperature for emergence SCr TSUM1 Temperature sum from emergence to anthesis SCr TSUM2 Temperature sum from anthesis to maturity SCr IDSL Switch for development options: temp only (0), +daylength SCr - (1), +vernalization (&gt;=2) DLO Optimal daylength for phenological development SCr hr DLC Critical daylength for phenological development SCr hr DVSI Initial development stage at emergence (may be &gt;0 for SCr - transplanted crops) DVSEND Final development stage SCr - DTSMTB Daily increase in temperature sum as a function of daily TCr mean temperature <p>State variables</p> Name Description Pbl Unit DVS Development stage Y - TSUM Temperature sum N TSUME Temperature sum for emergence N DOS Day of sowing N - DOE Day of emergence N - DOA Day of Anthesis N - DOM Day of maturity N - DOH Day of harvest N - STAGE Current stage (<code>emerging|vegetative|reproductive|mature</code>) N - <p>Rate variables</p> Name Description Pbl Unit DTSUME Increase in temperature sum for emergence N DTSUM Increase in temperature sum for anthesis or maturity N DVR Development rate Y <p>External dependencies:</p> <p>None</p> <p>Signals sent or handled</p> <p><code>DVS_Phenology</code> sends the <code>crop_finish</code> signal when maturity is reached and the <code>end_type</code> is 'maturity' or 'earliest'.</p> <p>Gradient mapping (which parameters have a gradient):</p> Output Parameters influencing it DVS ... TSUM ... <p>[!NOTE] Notice that the gradient \u2202DVS/\u2202TEFFMX is zero.</p> <p>[!NOTE] The parameter IDSL it is not differentiable since it is a switch.</p> <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>:param day: start date of the simulation</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Compute daily phenological development rates.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate phenology states and manage stage transitions.</p> </li> <li> <code>get_variable</code>             \u2013              <p>Return the value of the specified state or rate variable.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>device</code>           \u2013            <p>Get device from ComputeConfig.</p> </li> <li> <code>dtype</code>           \u2013            <p>Get dtype from ComputeConfig.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology.device","title":"device  <code>property</code>","text":"<pre><code>device\n</code></pre> <p>Get device from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Get dtype from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology.initialize","title":"initialize","text":"<pre><code>initialize(day, kiosk, parvalues)\n</code></pre> <p>:param day: start date of the simulation</p> <p>:param kiosk: variable kiosk of this PCSE  instance :param parvalues: <code>ParameterProvider</code> object providing parameters as         key/value pairs</p> Source code in <code>src/diffwofost/physical_models/crop/phenology.py</code> <pre><code>def initialize(self, day, kiosk, parvalues):\n    \"\"\":param day: start date of the simulation\n\n    :param kiosk: variable kiosk of this PCSE  instance\n    :param parvalues: `ParameterProvider` object providing parameters as\n            key/value pairs\n    \"\"\"\n    self.params = self.Parameters(parvalues)\n    self.params_shape = _get_params_shape(self.params)\n\n    # Initialize vernalisation for IDSL&gt;=2\n    # It has to be done in advance to get the correct params_shape\n    IDSL = _broadcast_to(\n        self.params.IDSL, self.params_shape, dtype=self.dtype, device=self.device\n    )\n    self.params.IDSL = IDSL\n    if torch.any(IDSL &gt;= 2):\n        if self.params_shape != ():\n            self.vernalisation = Vernalisation(\n                day, kiosk, parvalues, dvs_shape=self.params_shape\n            )\n        else:\n            self.vernalisation = Vernalisation(day, kiosk, parvalues)\n        if self.vernalisation.params_shape != self.params_shape:\n            self.params_shape = self.vernalisation.params_shape\n    else:\n        self.vernalisation = None\n\n    # After Vernalisation initialization the final params_shape may have changed.\n    self._cast_and_broadcast_params()\n\n    # Create scalar constants once at the beginning to avoid recreating them\n    self._ones = torch.ones(self.params_shape, dtype=self.dtype, device=self.device)\n    self._zeros = torch.zeros(self.params_shape, dtype=self.dtype, device=self.device)\n    self._epsilon = torch.tensor(1e-8, dtype=self.dtype, device=self.device)\n\n    # Initialize rates and kiosk\n    self.rates = self.RateVariables(kiosk)\n    self.kiosk = kiosk\n\n    self._connect_signal(self._on_CROP_FINISH, signal=signals.crop_finish)\n\n    # Define initial states\n    DVS, DOS, DOE, STAGE = self._get_initial_stage(day)\n    DVS = _broadcast_to(DVS, self.params_shape, dtype=self.dtype, device=self.device)\n\n    # Initialize all date tensors with -1 (not yet occurred)\n    DOS = _broadcast_to(DOS, self.params_shape, dtype=self.dtype, device=self.device)\n    DOE = _broadcast_to(DOE, self.params_shape, dtype=self.dtype, device=self.device)\n    DOA = torch.full(self.params_shape, -1.0, dtype=self.dtype, device=self.device)\n    DOM = torch.full(self.params_shape, -1.0, dtype=self.dtype, device=self.device)\n    DOH = torch.full(self.params_shape, -1.0, dtype=self.dtype, device=self.device)\n    STAGE = _broadcast_to(STAGE, self.params_shape, dtype=self.dtype, device=self.device)\n\n    # Also ensure TSUM and TSUME are properly shaped\n    TSUM = torch.zeros(\n        self.params_shape, dtype=self.dtype, device=self.device, requires_grad=True\n    )\n    TSUME = torch.zeros(\n        self.params_shape, dtype=self.dtype, device=self.device, requires_grad=True\n    )\n\n    self.states = self.StateVariables(\n        kiosk,\n        publish=\"DVS\",\n        TSUM=TSUM,\n        TSUME=TSUME,\n        DVS=DVS,\n        DOS=DOS,\n        DOE=DOE,\n        DOA=DOA,\n        DOM=DOM,\n        DOH=DOH,\n        STAGE=STAGE,\n    )\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day, drv)\n</code></pre> <p>Compute daily phenological development rates.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>Current simulation date.</p> </li> <li> <code>drv</code>           \u2013            <p>Meteorological driver object with at least TEMP and LAT.</p> </li> </ul> Logic <ol> <li>Photoperiod reduction (DVRED) if IDSL &gt;= 1 using daylength.</li> <li>Vernalisation factor (VERNFAC) if IDSL &gt;= 2 and in vegetative stage.</li> <li>Stage-specific:</li> <li>emerging: temperature sum for emergence (DTSUME), DVR via TSUMEM.</li> <li>vegetative: temperature sum (DTSUM) scaled by VERNFAC and DVRED.</li> <li>reproductive: temperature sum (DTSUM) only temperature-driven.</li> <li>mature: all rates zero.</li> </ol> Sets <p>r.DTSUME, r.DTSUM, r.DVR.</p> <p>Raises:</p> <ul> <li> <code>PCSEError</code>             \u2013            <p>If STAGE unrecognized.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/phenology.py</code> <pre><code>@prepare_rates\ndef calc_rates(self, day, drv):\n    \"\"\"Compute daily phenological development rates.\n\n    Args:\n        day (datetime.date): Current simulation date.\n        drv: Meteorological driver object with at least TEMP and LAT.\n\n    Logic:\n        1. Photoperiod reduction (DVRED) if IDSL &gt;= 1 using daylength.\n        2. Vernalisation factor (VERNFAC) if IDSL &gt;= 2 and in vegetative stage.\n        3. Stage-specific:\n           - emerging: temperature sum for emergence (DTSUME), DVR via TSUMEM.\n           - vegetative: temperature sum (DTSUM) scaled by VERNFAC and DVRED.\n           - reproductive: temperature sum (DTSUM) only temperature-driven.\n           - mature: all rates zero.\n\n    Sets:\n        r.DTSUME, r.DTSUM, r.DVR.\n\n    Raises:\n        PCSEError: If STAGE unrecognized.\n\n    \"\"\"\n    p = self.params\n    r = self.rates\n    s = self.states\n    shape = self.params_shape\n\n    # Day length sensitivity\n    DAYLP = daylength(day, drv.LAT)\n    DAYLP_t = _broadcast_to(DAYLP, shape, dtype=self.dtype, device=self.device)\n    # Compute DVRED conditionally based on IDSL &gt;= 1\n    safe_den = p.DLO - p.DLC\n    safe_den = safe_den.sign() * torch.maximum(torch.abs(safe_den), self._epsilon)\n    dvred_active = torch.clamp((DAYLP_t - p.DLC) / safe_den, 0.0, 1.0)\n    DVRED = torch.where(p.IDSL &gt;= 1, dvred_active, self._ones)\n\n    # Vernalisation factor - always compute if module exists\n    VERNFAC = self._ones\n    if hasattr(self, \"vernalisation\") and self.vernalisation is not None:\n        # Always call calc_rates (it handles stage internally now)\n        self.vernalisation.calc_rates(day, drv)\n        # Apply vernalisation only where IDSL &gt;= 2 AND in vegetative stage\n        is_vegetative = s.STAGE == 1\n        VERNFAC = torch.where(\n            (p.IDSL &gt;= 2) &amp; is_vegetative,\n            self.kiosk[\"VERNFAC\"],\n            self._ones,\n        )\n\n    TEMP = _get_drv(drv.TEMP, shape, self.dtype, self.device)\n\n    # Initialize all rate variables\n    r.DTSUME = self._zeros\n    r.DTSUM = self._zeros\n    r.DVR = self._zeros\n\n    # Compute rates for emerging stage (STAGE == 0)\n    is_emerging = s.STAGE == 0\n    if torch.any(is_emerging):\n        temp_diff = TEMP - p.TBASEM\n        # Ensure the maximum effective temperature difference is non-negative\n        max_diff = torch.clamp(p.TEFFMX - p.TBASEM, min=0.0)\n        dtsume_emerging = torch.clamp(temp_diff, min=0.0)\n        dtsume_emerging = torch.minimum(dtsume_emerging, max_diff)\n        safe_den = p.TSUMEM\n        safe_den = safe_den.sign() * torch.maximum(torch.abs(safe_den), self._epsilon)\n        dvr_emerging = 0.1 * dtsume_emerging / safe_den\n\n        r.DTSUME = torch.where(is_emerging, dtsume_emerging, r.DTSUME)\n        r.DVR = torch.where(is_emerging, dvr_emerging, r.DVR)\n\n    # Compute rates for vegetative stage (STAGE == 1)\n    is_vegetative = s.STAGE == 1\n    if torch.any(is_vegetative):\n        dtsum_vegetative = p.DTSMTB(TEMP) * VERNFAC * DVRED\n        safe_den = p.TSUM1\n        safe_den = safe_den.sign() * torch.maximum(torch.abs(safe_den), self._epsilon)\n        dvr_vegetative = dtsum_vegetative / safe_den\n\n        r.DTSUM = torch.where(is_vegetative, dtsum_vegetative, r.DTSUM)\n        r.DVR = torch.where(is_vegetative, dvr_vegetative, r.DVR)\n\n    # Compute rates for reproductive stage (STAGE == 2)\n    is_reproductive = s.STAGE == 2\n    if torch.any(is_reproductive):\n        dtsum_reproductive = p.DTSMTB(TEMP)\n        safe_den = p.TSUM2\n        safe_den = safe_den.sign() * torch.maximum(torch.abs(safe_den), self._epsilon)\n        dvr_reproductive = dtsum_reproductive / safe_den\n\n        r.DTSUM = torch.where(is_reproductive, dtsum_reproductive, r.DTSUM)\n        r.DVR = torch.where(is_reproductive, dvr_reproductive, r.DVR)\n\n    # Mature stage (STAGE == 3) keeps zeros (already initialized)\n\n    msg = \"Finished rate calculation for %s\"\n    self.logger.debug(msg % day)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology.integrate","title":"integrate","text":"<pre><code>integrate(day, delt=1.0)\n</code></pre> <p>Integrate phenology states and manage stage transitions.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>Current simulation day.</p> </li> <li> <code>delt</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Timestep length in days (default 1.0).</p> </li> </ul> Sequence <ul> <li>Integrates vernalisation module if active and in vegetative stage.</li> <li>Accumulates TSUME, TSUM, advances DVS by DVR.</li> <li>Checks threshold crossings to move through stages:     emerging -&gt; vegetative (DVS &gt;= 0)     vegetative -&gt; reproductive (DVS &gt;= 1)     reproductive -&gt; mature (DVS &gt;= DVSEND)</li> </ul> Side Effects <ul> <li>Emits crop_emerged signal on emergence.</li> <li>Emits crop_finish signal at maturity if end type matches.</li> </ul> Notes <p>Caps DVS at stage boundary values.</p> <p>Raises:</p> <ul> <li> <code>PCSEError</code>             \u2013            <p>If STAGE undefined.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/phenology.py</code> <pre><code>@prepare_states\ndef integrate(self, day, delt=1.0):\n    \"\"\"Integrate phenology states and manage stage transitions.\n\n    Args:\n        day (datetime.date): Current simulation day.\n        delt (float, optional): Timestep length in days (default 1.0).\n\n    Sequence:\n        - Integrates vernalisation module if active and in vegetative stage.\n        - Accumulates TSUME, TSUM, advances DVS by DVR.\n        - Checks threshold crossings to move through stages:\n            emerging -&gt; vegetative (DVS &gt;= 0)\n            vegetative -&gt; reproductive (DVS &gt;= 1)\n            reproductive -&gt; mature (DVS &gt;= DVSEND)\n\n    Side Effects:\n        - Emits crop_emerged signal on emergence.\n        - Emits crop_finish signal at maturity if end type matches.\n\n    Notes:\n        Caps DVS at stage boundary values.\n\n    Raises:\n        PCSEError: If STAGE undefined.\n\n    \"\"\"\n    p = self.params\n    r = self.rates\n    s = self.states\n    shape = self.params_shape\n\n    # Integrate vernalisation module\n    if self.vernalisation:\n        # Save a copy of state\n        state_copy = _snapshot_state(self.vernalisation.states)\n        mask_IDSL = p.IDSL &gt;= 2\n\n        # Check if any element is in vegetative stage i.e. stage 1\n        mask_STAGE = mask_IDSL &amp; (s.STAGE == 1)\n        self.vernalisation.integrate(day, delt)\n        state_integrated = _snapshot_state(self.vernalisation.states)\n\n        # Restore original state\n        _restore_state(self.vernalisation.states, state_copy)\n        self.vernalisation.touch()\n        state_touched = _snapshot_state(self.vernalisation.states)\n\n        # Apply the masks\n        for name in state_copy:\n            # results of vernalisation module\n            vernalisation_states = torch.where(\n                mask_STAGE, state_integrated[name], state_touched[name]\n            )\n            setattr(\n                self.vernalisation.states,\n                name,\n                torch.where(mask_IDSL, vernalisation_states, state_copy[name]),\n            )\n\n    # Integrate phenologic states\n    s.TSUME = s.TSUME + r.DTSUME\n    s.DVS = s.DVS + r.DVR\n    s.TSUM = s.TSUM + r.DTSUM\n\n    day_ordinal = torch.tensor(day.toordinal(), dtype=self.dtype, device=self.device)\n\n    # Check transitions for emerging -&gt; vegetative (STAGE 0 -&gt; 1)\n    is_emerging = s.STAGE == 0\n    should_emerge = is_emerging &amp; (s.DVS &gt;= 0.0)\n    s.STAGE = torch.where(\n        should_emerge, torch.ones(shape, dtype=torch.long, device=self.device), s.STAGE\n    )\n    s.DOE = torch.where(\n        should_emerge,\n        torch.full(shape, day_ordinal, dtype=self.dtype, device=self.device),\n        s.DOE,\n    )\n    s.DVS = torch.where(should_emerge, torch.clamp(s.DVS, max=0.0), s.DVS)\n\n    # Send signal if any crop emerged (only once per day)\n    if torch.any(should_emerge):\n        self._send_signal(signals.crop_emerged)\n\n    # Check transitions for vegetative -&gt; reproductive (STAGE 1 -&gt; 2)\n    is_vegetative = s.STAGE == 1\n    should_flower = is_vegetative &amp; (s.DVS &gt;= 1.0)\n    s.STAGE = torch.where(\n        should_flower, torch.full(shape, 2, dtype=torch.long, device=self.device), s.STAGE\n    )\n    s.DOA = torch.where(\n        should_flower,\n        torch.full(shape, day_ordinal, dtype=self.dtype, device=self.device),\n        s.DOA,\n    )\n    s.DVS = torch.where(should_flower, torch.clamp(s.DVS, max=1.0), s.DVS)\n\n    # Check transitions for reproductive -&gt; mature (STAGE 2 -&gt; 3)\n    is_reproductive = s.STAGE == 2\n    should_mature = is_reproductive &amp; (s.DVS &gt;= p.DVSEND)\n    s.STAGE = torch.where(\n        should_mature, torch.full(shape, 3, dtype=torch.long, device=self.device), s.STAGE\n    )\n    s.DOM = torch.where(\n        should_mature,\n        torch.full(shape, day_ordinal, dtype=self.dtype, device=self.device),\n        s.DOM,\n    )\n    s.DVS = torch.where(should_mature, torch.minimum(s.DVS, p.DVSEND), s.DVS)\n\n    # Send crop_finish signal if maturity reached for one.\n    # assumption is that all elements mature simultaneously\n    # TODO: revisit this when fixing engine for agromanager\n    if torch.any(should_mature) and p.CROP_END_TYPE in [\"maturity\", \"earliest\"]:\n        self._send_signal(\n            signal=signals.crop_finish,\n            day=day,\n            finish_type=\"maturity\",\n            crop_delete=True,\n        )\n\n    msg = \"Finished state integration for %s\"\n    self.logger.debug(msg % day)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.phenology.DVS_Phenology.get_variable","title":"get_variable","text":"<pre><code>get_variable(varname)\n</code></pre> <p>Return the value of the specified state or rate variable.</p> <p>:param varname: Name of the variable.</p> <p>Note that the <code>get_variable()</code> will searches for <code>varname</code> exactly as specified (case sensitive).</p> Source code in <code>src/diffwofost/physical_models/crop/phenology.py</code> <pre><code>def get_variable(self, varname):\n    # TODO: should be removed while fixing #49. this is needed because\n    # conditions are applied on STAGE in pcse.crop.wofost72.py\n    \"\"\"Return the value of the specified state or rate variable.\n\n    :param varname: Name of the variable.\n\n    Note that the `get_variable()` will searches for `varname` exactly\n    as specified (case sensitive).\n    \"\"\"\n    if varname == \"STAGE\":\n        # Return string representation of current stage\n        stage_map = {\n            0: \"emerging\",\n            1: \"vegetative\",\n            2: \"reproductive\",\n            3: \"mature\",\n        }\n        stage_value = self.states.STAGE\n        if stage_value.dim() != 0:\n            stage_id = stage_value.flatten()[0].item()\n        else:\n            stage_id = stage_value.item()\n        return stage_map[stage_id]\n\n    # Search for variable in the current object, then traverse the hierarchy\n    value = None\n    if hasattr(self.states, varname):\n        value = getattr(self.states, varname)\n    elif hasattr(self.rates, varname):\n        value = getattr(self.rates, varname)\n    # Query individual sub-SimObject for existence of variable v\n    else:\n        for simobj in self.subSimObjects:\n            value = simobj.get_variable(varname)\n            if value is not None:\n                break\n    return value\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.partitioning.DVS_Partitioning","title":"diffwofost.physical_models.crop.partitioning.DVS_Partitioning","text":"<p>               Bases: <code>_BaseDVSPartitioning</code></p> <p>Class for assimilate partitioning based on development stage (DVS).</p> <p><code>DVS_Partitioning</code> calculates the partitioning of the assimilates to roots, stems, leaves and storage organs using fixed partitioning tables as a function of crop development stage. The available assimilates are first split into below-ground and aboveground using the values in FRTB. In a second stage they are split into leaves (FLTB), stems (FSTB) and storage organs (FOTB).</p> <p>Since the partitioning fractions are derived from the state variable DVS they are regarded state variables as well.</p> <p>Simulation parameters (To be provided in cropdata dictionary):</p> Name Description Type Unit FRTB Partitioning to roots as a function of development stage TCr - FSTB Partitioning to stems as a function of development stage TCr - FLTB Partitioning to leaves as a function of development stage TCr - FOTB Partitioning to storage organs as a function of development  stage TCr - <p>State variables</p> Name Description Pbl Unit FR Fraction partitioned to roots Y - FS Fraction partitioned to stems Y - FL Fraction partitioned to leaves Y - FO Fraction partitioned to storage organs Y - PF Partitioning factors packed in tuple N - <p>Rate variables</p> <p>None</p> <p>External dependencies:</p> Name Description Provided by Unit DVS Crop development stage DVS_Phenology - <p>Outputs</p> Name Description Pbl Unit FR Fraction partitioned to roots Y - FL Fraction partitioned to leaves Y - FS Fraction partitioned to stems Y - FO Fraction partitioned to storage organs Y - <p>Gradient mapping (which parameters have a gradient):</p> Output Parameters influencing it FR FRTB, DVS FL FLTB, DVS FS FSTB, DVS FO FOTB, DVS <p>Exceptions raised</p> <p>A PartitioningError is raised if the partitioning coefficients to leaves, stems and storage organs on a given day do not add up to 1.</p> <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>Initialize the DVS_Partitioning simulation object.</p> </li> <li> <code>integrate</code>             \u2013              <p>Update partitioning factors based on development stage (DVS).</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Return partitioning factors based on current DVS.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.partitioning.DVS_Partitioning.initialize","title":"initialize","text":"<pre><code>initialize(day, kiosk, parvalues)\n</code></pre> <p>Initialize the DVS_Partitioning simulation object.</p> <p>Parameters:</p> <ul> <li> <code>day</code>           \u2013            <p>Start date of the simulation.</p> </li> <li> <code>kiosk</code>               (<code>VariableKiosk</code>)           \u2013            <p>Variable kiosk of this PCSE instance.</p> </li> <li> <code>parvalues</code>               (<code>ParameterProvider</code>)           \u2013            <p>Object providing parameters as key/value pairs.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/partitioning.py</code> <pre><code>def initialize(self, day, kiosk, parvalues):\n    \"\"\"Initialize the DVS_Partitioning simulation object.\n\n    Args:\n        day: Start date of the simulation.\n        kiosk (VariableKiosk): Variable kiosk of this PCSE instance.\n        parvalues (ParameterProvider): Object providing parameters as\n            key/value pairs.\n    \"\"\"\n    self._initialize_from_tables(kiosk, parvalues)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.partitioning.DVS_Partitioning.integrate","title":"integrate","text":"<pre><code>integrate(day, delt=1.0)\n</code></pre> <p>Update partitioning factors based on development stage (DVS).</p> Source code in <code>src/diffwofost/physical_models/crop/partitioning.py</code> <pre><code>@prepare_states\ndef integrate(self, day, delt=1.0):\n    \"\"\"Update partitioning factors based on development stage (DVS).\"\"\"\n    self._update_from_tables()\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.partitioning.DVS_Partitioning.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day, drv)\n</code></pre> <p>Return partitioning factors based on current DVS.</p> <p>Rate calculation does nothing for partitioning as it is a derived state.</p> Source code in <code>src/diffwofost/physical_models/crop/partitioning.py</code> <pre><code>def calc_rates(self, day, drv):\n    \"\"\"Return partitioning factors based on current DVS.\n\n    Rate calculation does nothing for partitioning as it is a derived state.\n    \"\"\"\n    return self.states.PF\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation","title":"diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Class implementing a WOFOST/SUCROS style assimilation routine.</p> <p>WOFOST calculates the daily gross CO2 assimilation rate of a crop from the absorbed radiation and the photosynthesis-light response curve of individual leaves. This response is dependent on temperature and leaf age. The absorbed radiation is calculated from the total incoming radiation and the leaf area. Daily gross CO2 assimilation is obtained by integrating the assimilation rates over the leaf layers and over the day.</p> <p>Simulation parameters (provide in cropdata dictionary)</p> Name Description Type Unit AMAXTB Max. leaf CO2 assimilation rate as function of DVS TCr kg CO2 ha\u207b\u00b9 leaf h\u207b\u00b9 EFFTB Light use effic. single leaf as a function of daily mean temperature TCr kg CO2 ha\u207b\u00b9 h\u207b\u00b9 /(J m\u207b\u00b2 s\u207b\u00b9) KDIFTB Extinction coefficient for diffuse visible light as function of DVS TCr - TMPFTB Reduction factor on AMAX as function of daily mean temperature TCr - TMNFTB Reduction factor on AMAX as function of daily minimum temperature TCr - <p>Rate variables This class returns the potential gross assimilation rate 'PGASS' directly from the <code>__call__()</code> method, but also includes it as a rate variable.</p> Name Description Pbl Unit PGASS Potential gross assimilation Y kg CH2O ha\u207b\u00b9 d\u207b\u00b9 <p>External dependencies</p> Name Description Provided by Unit DVS Crop development stage DVS_Phenology - LAI Leaf area index Leaf_dynamics - <p>Weather inputs used</p> Name Description Unit IRRAD Daily shortwave radiation J m\u207b\u00b2 d\u207b\u00b9 DTEMP Daily mean temperature \u00b0C TMIN Daily minimum temperature \u00b0C LAT Latitude degrees <p>Outputs</p> Name Description Pbl Unit PGASS Potential gross assimilation Y kg CH2O ha\u207b\u00b9 d\u207b\u00b9 <p>Gradient mapping (which parameters have a gradient):</p> Output Parameters influencing it PGASS AMAXTB, EFFTB, KDIFTB, TMPFTB, TMNFTB <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>Initialize the assimilation module.</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Compute the potential gross assimilation rate (PGASS).</p> </li> <li> <code>__call__</code>             \u2013              <p>Calculate and return the potential gross assimilation rate (PGASS).</p> </li> <li> <code>integrate</code>             \u2013              <p>No state variables to integrate for this module.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>device</code>           \u2013            <p>Get device from ComputeConfig.</p> </li> <li> <code>dtype</code>           \u2013            <p>Get dtype from ComputeConfig.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation.device","title":"device  <code>property</code>","text":"<pre><code>device\n</code></pre> <p>Get device from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Get dtype from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation.initialize","title":"initialize","text":"<pre><code>initialize(day: date, kiosk: VariableKiosk, parvalues: ParameterProvider) -&gt; None\n</code></pre> <p>Initialize the assimilation module.</p> Source code in <code>src/diffwofost/physical_models/crop/assimilation.py</code> <pre><code>def initialize(\n    self, day: datetime.date, kiosk: VariableKiosk, parvalues: ParameterProvider\n) -&gt; None:\n    \"\"\"Initialize the assimilation module.\"\"\"\n    self.kiosk = kiosk\n    self.params = self.Parameters(parvalues)\n    self.params_shape = _get_params_shape(self.params)\n    self.rates = self.RateVariables(kiosk, publish=[\"PGASS\"])\n\n    # 7-day running average buffer for TMIN (stored as tensors).\n    self._tmn_window = deque(maxlen=7)\n    self._tmn_window_mask = deque(maxlen=7)\n    # Reused scalar constants\n    self._epsilon = torch.tensor(1e-12, dtype=self.dtype, device=self.device)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day: date = None, drv: WeatherDataContainer = None) -&gt; None\n</code></pre> <p>Compute the potential gross assimilation rate (PGASS).</p> Source code in <code>src/diffwofost/physical_models/crop/assimilation.py</code> <pre><code>@prepare_rates\ndef calc_rates(self, day: datetime.date = None, drv: WeatherDataContainer = None) -&gt; None:\n    \"\"\"Compute the potential gross assimilation rate (PGASS).\"\"\"\n    p = self.params\n    r = self.rates\n    k = self.kiosk\n\n    _exist_required_external_variables(k)\n\n    # External states\n    dvs = _broadcast_to(k[\"DVS\"], self.params_shape, dtype=self.dtype, device=self.device)\n    lai = _broadcast_to(k[\"LAI\"], self.params_shape, dtype=self.dtype, device=self.device)\n\n    # Weather drivers\n    irrad = _get_drv(drv.IRRAD, self.params_shape, dtype=self.dtype, device=self.device)\n    dtemp = _get_drv(drv.DTEMP, self.params_shape, dtype=self.dtype, device=self.device)\n    tmin = _get_drv(drv.TMIN, self.params_shape, dtype=self.dtype, device=self.device)\n\n    # Assimilation is zero before crop emergence (DVS &lt; 0)\n    dvs_mask = (dvs &gt;= 0).to(dtype=self.dtype)\n    # 7-day running average of TMIN\n    self._tmn_window.appendleft(tmin * dvs_mask)\n    self._tmn_window_mask.appendleft(dvs_mask)\n    tmin_stack = torch.stack(list(self._tmn_window), dim=0)\n    mask_stack = torch.stack(list(self._tmn_window_mask), dim=0)\n    tminra = tmin_stack.sum(dim=0) / (mask_stack.sum(dim=0) + 1e-8)\n\n    # Astronomical variables (computed with PCSE util; then broadcast to tensors)\n    lat = _as_python_float(drv.LAT)\n    irrad_for_astro = _as_python_float(drv.IRRAD)\n    dayl, _daylp, sinld, cosld, difpp, _atmtr, dsinbe, _angot = astro(day, lat, irrad_for_astro)\n\n    dayl_t = _broadcast_to(dayl, self.params_shape, dtype=self.dtype, device=self.device)\n    sinld_t = _broadcast_to(sinld, self.params_shape, dtype=self.dtype, device=self.device)\n    cosld_t = _broadcast_to(cosld, self.params_shape, dtype=self.dtype, device=self.device)\n    difpp_t = _broadcast_to(difpp, self.params_shape, dtype=self.dtype, device=self.device)\n    dsinbe_t = _broadcast_to(dsinbe, self.params_shape, dtype=self.dtype, device=self.device)\n\n    # Parameter tables\n    amax = p.AMAXTB(dvs)\n    amax = amax * p.TMPFTB(dtemp)\n    kdif = p.KDIFTB(dvs)\n    eff = p.EFFTB(dtemp)\n\n    dtga = totass7(\n        dayl_t,\n        amax,\n        eff,\n        lai,\n        kdif,\n        irrad,\n        difpp_t,\n        dsinbe_t,\n        sinld_t,\n        cosld_t,\n        epsilon=self._epsilon,\n    )\n\n    # Correction for low minimum temperature potential\n    dtga = dtga * p.TMNFTB(tminra)\n\n    # Convert kg CO2 -&gt; kg CH2O\n    pgass = dtga * (30.0 / 44.0)\n\n    # Assimilation is zero before crop emergence (DVS &lt; 0)\n    r.PGASS = pgass * dvs_mask\n    return r.PGASS\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation.__call__","title":"__call__","text":"<pre><code>__call__(day: date = None, drv: WeatherDataContainer = None) -&gt; Tensor\n</code></pre> <p>Calculate and return the potential gross assimilation rate (PGASS).</p> Source code in <code>src/diffwofost/physical_models/crop/assimilation.py</code> <pre><code>def __call__(self, day: datetime.date = None, drv: WeatherDataContainer = None) -&gt; torch.Tensor:\n    \"\"\"Calculate and return the potential gross assimilation rate (PGASS).\"\"\"\n    return self.calc_rates(day, drv)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.assimilation.WOFOST72_Assimilation.integrate","title":"integrate","text":"<pre><code>integrate(day: date = None, delt=1.0) -&gt; None\n</code></pre> <p>No state variables to integrate for this module.</p> Source code in <code>src/diffwofost/physical_models/crop/assimilation.py</code> <pre><code>@prepare_states\ndef integrate(self, day: datetime.date = None, delt=1.0) -&gt; None:\n    \"\"\"No state variables to integrate for this module.\"\"\"\n    return\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics","title":"diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Leaf dynamics for the WOFOST crop model.</p> <p>Implementation of biomass partitioning to leaves, growth and senenscence of leaves. WOFOST keeps track of the biomass that has been partitioned to the leaves for each day (variable <code>LV</code>), which is called a leaf class). For each leaf class the leaf age (variable 'LVAGE') and specific leaf area (variable <code>SLA</code>) are also registered. Total living leaf biomass is calculated by summing the biomass values for all leaf classes. Similarly, leaf area is calculated by summing leaf biomass times specific leaf area (<code>LV</code> * <code>SLA</code>).</p> <p>Senescense of the leaves can occur as a result of physiological age, drought stress or self-shading.</p> <p>Simulation parameters (provide in cropdata dictionary)</p> Name Description Type Unit RGRLAI Maximum relative increase in LAI. SCr ha ha\u207b\u00b9 d\u207b\u00b9 SPAN Life span of leaves growing at 35 Celsius SCr d TBASE Lower threshold temp. for ageing of leaves SCr C PERDL Max. relative death rate of leaves due to water stress SCr TDWI Initial total crop dry weight SCr kg ha\u207b\u00b9 KDIFTB Extinction coefficient for diffuse visible light as function of DVS TCr SLATB Specific leaf area as a function of DVS TCr ha kg\u207b\u00b9 <p>State variables</p> Name Description Pbl Unit LV Leaf biomass per leaf class N kg ha\u207b\u00b9 SLA Specific leaf area per leaf class N ha kg\u207b\u00b9 LVAGE Leaf age per leaf class N d LVSUM Sum of LV N kg ha\u207b\u00b9 LAIEM LAI at emergence N - LASUM Total leaf area as sum of LV*SLA, not including stem and pod area N - LAIEXP LAI value under theoretical exponential growth N - LAIMAX Maximum LAI reached during growth cycle N - LAI Leaf area index, including stem and pod area Y - WLV Dry weight of living leaves Y kg ha\u207b\u00b9 DWLV Dry weight of dead leaves N kg ha\u207b\u00b9 TWLV Dry weight of total leaves (living + dead) Y kg ha\u207b\u00b9 <p>Rate variables</p> Name Description Pbl Unit GRLV Growth rate leaves N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV1 Death rate leaves due to water stress N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV2 Death rate leaves due to self-shading N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV3 Death rate leaves due to frost kill N kg ha\u207b\u00b9 d\u207b\u00b9 DSLV Maximum of DSLV1, DSLV2, DSLV3 N kg ha\u207b\u00b9 d\u207b\u00b9 DALV Death rate leaves due to aging N kg ha\u207b\u00b9 d\u207b\u00b9 DRLV Death rate leaves as a combination of DSLV and DALV N kg ha\u207b\u00b9 d\u207b\u00b9 SLAT Specific leaf area for current time step, adjusted for source/sink limited leaf expansion rate N ha kg\u207b\u00b9 FYSAGE Increase in physiological leaf age N - GLAIEX Sink-limited leaf expansion rate (exponential curve) N ha ha\u207b\u00b9 d\u207b\u00b9 GLASOL Source-limited leaf expansion rate (biomass increase) N ha ha\u207b\u00b9 d\u207b\u00b9 <p>External dependencies</p> Name Description Provided by Unit DVS Crop development stage DVS_Phenology - FL Fraction biomass to leaves DVS_Partitioning - FR Fraction biomass to roots DVS_Partitioning - SAI Stem area index WOFOST_Stem_Dynamics - PAI Pod area index WOFOST_Storage_Organ_Dynamics - TRA Transpiration rate Evapotranspiration cm day\u207b\u00b9 ? TRAMX Maximum transpiration rate Evapotranspiration cm day\u207b\u00b9 ? ADMI Above-ground dry matter increase CropSimulation kg ha\u207b\u00b9 d\u207b\u00b9 RFTRA Reduction factor for transpiration (water &amp; oxygen) Y - RF_FROST Reduction factor frost kill FROSTOL (optional) - <p>Outputs</p> Name Description Pbl Unit LAI Leaf area index, including stem and pod area Y - TWLV Dry weight of total leaves (living + dead) Y kg ha\u207b\u00b9 <p>Gradient mapping (which parameters have a gradient):</p> Output Parameters influencing it LAI TDWI, SPAN, RGRLAI, TBASE, KDIFTB, SLATB TWLV TDWI, PERDL <p>[!NOTE] Notice that the following gradients are zero:     - \u2202SPAN/\u2202TWLV     - \u2202PERDL/\u2202TWLV     - \u2202KDIFTB/\u2202LAI</p> <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>Initialize the WOFOST_Leaf_Dynamics simulation object.</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Calculate the rates of change for the leaf dynamics.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate the leaf dynamics state variables.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>device</code>           \u2013            <p>Get device from ComputeConfig.</p> </li> <li> <code>dtype</code>           \u2013            <p>Get dtype from ComputeConfig.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.device","title":"device  <code>property</code>","text":"<pre><code>device\n</code></pre> <p>Get device from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Get dtype from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.initialize","title":"initialize","text":"<pre><code>initialize(day: date, kiosk: VariableKiosk, parvalues: ParameterProvider) -&gt; None\n</code></pre> <p>Initialize the WOFOST_Leaf_Dynamics simulation object.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The starting date of the simulation.</p> </li> <li> <code>kiosk</code>               (<code>VariableKiosk</code>)           \u2013            <p>A container for registering and publishing (internal and external) state variables. See PCSE documentation for details.</p> </li> <li> <code>parvalues</code>               (<code>ParameterProvider</code>)           \u2013            <p>A dictionary-like container holding all parameter sets (crop, soil, site) as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/leaf_dynamics.py</code> <pre><code>def initialize(\n    self, day: datetime.date, kiosk: VariableKiosk, parvalues: ParameterProvider\n) -&gt; None:\n    \"\"\"Initialize the WOFOST_Leaf_Dynamics simulation object.\n\n    Args:\n        day (datetime.date): The starting date of the simulation.\n        kiosk (VariableKiosk): A container for registering and publishing\n            (internal and external) state variables. See PCSE documentation for\n            details.\n        parvalues (ParameterProvider): A dictionary-like container holding\n            all parameter sets (crop, soil, site) as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    self.START_DATE = day\n    self.kiosk = kiosk\n    # TODO check if parvalues are already torch.nn.Parameters\n    self.params = self.Parameters(parvalues)\n    self.rates = self.RateVariables(kiosk)\n\n    # Create scalar constants once at the beginning to avoid recreating them\n    self._zero = torch.tensor(0.0, dtype=self.dtype, device=self.device)\n    self._epsilon = torch.tensor(1e-12, dtype=self.dtype, device=self.device)\n    self._sigmoid_sharpness = torch.tensor(1000, dtype=self.dtype, device=self.device)\n    self._sigmoid_epsilon = torch.tensor(1e-14, dtype=self.dtype, device=self.device)\n\n    # CALCULATE INITIAL STATE VARIABLES\n    # check for required external variables\n    _exist_required_external_variables(self.kiosk)\n    # TODO check if external variables are already torch tensors\n\n    # Get kiosk values and ensure they are on the correct device\n    FL = torch.as_tensor(self.kiosk[\"FL\"], dtype=self.dtype, device=self.device)\n    FR = torch.as_tensor(self.kiosk[\"FR\"], dtype=self.dtype, device=self.device)\n    DVS = torch.as_tensor(self.kiosk[\"DVS\"], dtype=self.dtype, device=self.device)\n\n    params = self.params\n    self.params_shape = _get_params_shape(params)\n\n    # Initial leaf biomass\n    TDWI = _broadcast_to(params.TDWI, self.params_shape, dtype=self.dtype, device=self.device)\n    WLV = (TDWI * (1 - FR)) * FL\n    DWLV = torch.zeros(self.params_shape, dtype=self.dtype, device=self.device)\n    TWLV = WLV + DWLV\n\n    # Initialize leaf classes (SLA, age and weight)\n    SLA = torch.zeros((*self.params_shape, self.MAX_DAYS), dtype=self.dtype, device=self.device)\n    LVAGE = torch.zeros(\n        (*self.params_shape, self.MAX_DAYS), dtype=self.dtype, device=self.device\n    )\n    LV = torch.zeros((*self.params_shape, self.MAX_DAYS), dtype=self.dtype, device=self.device)\n    SLA[..., 0] = params.SLATB(DVS).to(dtype=self.dtype, device=self.device)\n    LV[..., 0] = WLV\n\n    # Initial values for leaf area\n    LAIEM = LV[..., 0] * SLA[..., 0]\n    LASUM = LAIEM\n    LAIEXP = LAIEM\n    LAIMAX = LAIEM\n    SAI = torch.as_tensor(self.kiosk[\"SAI\"], dtype=self.dtype, device=self.device)\n    PAI = torch.as_tensor(self.kiosk[\"PAI\"], dtype=self.dtype, device=self.device)\n    LAI = LASUM + SAI + PAI\n\n    # Initialize StateVariables object\n    self.states = self.StateVariables(\n        kiosk,\n        publish=[\"LAI\", \"TWLV\", \"WLV\"],\n        LV=LV,\n        SLA=SLA,\n        LVAGE=LVAGE,\n        LAIEM=LAIEM,\n        LASUM=LASUM,\n        LAIEXP=LAIEXP,\n        LAIMAX=LAIMAX,\n        LAI=LAI,\n        WLV=WLV,\n        DWLV=DWLV,\n        TWLV=TWLV,\n    )\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day: date, drv: WeatherDataContainer) -&gt; None\n</code></pre> <p>Calculate the rates of change for the leaf dynamics.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>drv</code>               (<code>WeatherDataContainer</code>)           \u2013            <p>A dictionary-like container holding weather data elements as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/leaf_dynamics.py</code> <pre><code>@prepare_rates\ndef calc_rates(self, day: datetime.date, drv: WeatherDataContainer) -&gt; None:\n    \"\"\"Calculate the rates of change for the leaf dynamics.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        drv (WeatherDataContainer, optional): A dictionary-like container holding\n            weather data elements as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    r = self.rates\n    s = self.states\n    p = self.params\n    k = self.kiosk\n\n    # If DVS &lt; 0, the crop has not yet emerged, so we zerofy the rates using mask\n    # A mask (0 if DVS &lt; 0, 1 if DVS &gt;= 0)\n    DVS = torch.as_tensor(k[\"DVS\"], dtype=self.dtype, device=self.device)\n    dvs_mask = (DVS &gt;= 0).to(dtype=self.dtype).to(device=self.device)\n\n    # Growth rate leaves\n    # weight of new leaves\n    r.GRLV = dvs_mask * k.ADMI * k.FL\n\n    # death of leaves due to water/oxygen stress\n    RFTRA = _broadcast_to(k.RFTRA, self.params_shape, dtype=self.dtype, device=self.device)\n    PERDL = _broadcast_to(p.PERDL, self.params_shape, dtype=self.dtype, device=self.device)\n    r.DSLV1 = dvs_mask * s.WLV * (1.0 - RFTRA) * PERDL\n\n    # death due to self shading cause by high LAI\n    DVS = _broadcast_to(\n        self.kiosk[\"DVS\"], self.params_shape, dtype=self.dtype, device=self.device\n    )\n    KDIFTB = p.KDIFTB.to(device=self.device, dtype=self.dtype)\n    LAICR = 3.2 / KDIFTB(DVS)\n    r.DSLV2 = dvs_mask * s.WLV * torch.clamp(0.03 * (s.LAI - LAICR) / LAICR, 0.0, 0.03)\n\n    # Death of leaves due to frost damage as determined by\n    # Reduction Factor Frost \"RF_FROST\"\n    if \"RF_FROST\" in self.kiosk:\n        r.DSLV3 = s.WLV * k.RF_FROST\n    else:\n        r.DSLV3 = torch.zeros_like(s.WLV, dtype=self.dtype)\n\n    r.DSLV3 = dvs_mask * r.DSLV3\n\n    # leaf death equals maximum of water stress, shading and frost\n    r.DSLV = torch.maximum(torch.maximum(r.DSLV1, r.DSLV2), r.DSLV3)\n    r.DSLV = dvs_mask * r.DSLV\n\n    # Determine how much leaf biomass classes have to die in states.LV,\n    # given the a life span &gt; SPAN, these classes will be accumulated\n    # in DALV.\n    # Note that the actual leaf death is imposed on the array LV during the\n    # state integration step.\n    tSPAN = _broadcast_to(\n        p.SPAN, s.LVAGE.shape, dtype=self.dtype, device=self.device\n    )  # Broadcast to same shape\n\n    # Using a sigmoid here instead of a conditional statement on the value of\n    # SPAN because the latter would not allow for the gradient to be tracked.\n    # the if statement `p.SPAN.requires_grad` to avoid unnecessary\n    # approximation when SPAN is not a learnable parameter.\n    # here we use STE (straight through estimator) method.\n    # TODO: sharpness can be exposed as a parameter\n    if p.SPAN.requires_grad:\n        # soft mask using sigmoid\n        soft_mask = torch.sigmoid(\n            (s.LVAGE - tSPAN - self._sigmoid_epsilon) / self._sigmoid_sharpness\n        ).to(dtype=self.dtype)\n\n        # originial hard mask\n        hard_mask = (s.LVAGE &gt; tSPAN).to(dtype=self.dtype)\n\n        # STE method. Here detach is used to stop the gradient flow. This\n        # way, during backpropagation, the gradient is computed only through\n        # the `soft_mask``, while during the forward pass, the `hard_mask``\n        # is used.\n        span_mask = hard_mask.detach() + soft_mask - soft_mask.detach()\n    else:\n        span_mask = (s.LVAGE &gt; tSPAN).to(dtype=self.dtype)\n\n    r.DALV = torch.sum(span_mask * s.LV, dim=-1)\n    r.DALV = dvs_mask * r.DALV\n\n    # Total death rate leaves\n    r.DRLV = torch.maximum(r.DSLV, r.DALV)\n\n    # Get the temperature from the drv\n    TEMP = _get_drv(drv.TEMP, self.params_shape, self.dtype, self.device)\n\n    # physiologic ageing of leaves per time step\n    TBASE = _broadcast_to(p.TBASE, self.params_shape, dtype=self.dtype, device=self.device)\n    FYSAGE = (TEMP - TBASE) / (35.0 - TBASE)\n    r.FYSAGE = dvs_mask * torch.clamp(FYSAGE, 0.0)\n\n    # specific leaf area of leaves per time step\n    SLATB = p.SLATB.to(device=self.device, dtype=self.dtype)\n    r.SLAT = dvs_mask * SLATB(DVS)\n\n    # leaf area not to exceed exponential growth curve\n    is_lai_exp = s.LAIEXP &lt; 6.0\n    DTEFF = torch.clamp(TEMP - TBASE, 0.0)\n\n    # NOTE: conditional statements do not allow for the gradient to be\n    # tracked through the condition. Thus, the gradient with respect to\n    # parameters that contribute to `is_lai_exp` (e.g. RGRLAI and TBASE)\n    # are expected to be incorrect.\n    RGRLAI = _broadcast_to(p.RGRLAI, self.params_shape, dtype=self.dtype, device=self.device)\n    r.GLAIEX = torch.where(\n        dvs_mask.bool(),\n        torch.where(is_lai_exp, s.LAIEXP * RGRLAI * DTEFF, r.GLAIEX),\n        self._zero,\n    )\n\n    # source-limited increase in leaf area\n    r.GLASOL = torch.where(\n        dvs_mask.bool(),\n        torch.where(is_lai_exp, r.GRLV * r.SLAT, r.GLASOL),\n        self._zero,\n    )\n\n    # sink-limited increase in leaf area\n    GLA = torch.minimum(r.GLAIEX, r.GLASOL)\n\n    # adjustment of specific leaf area of youngest leaf class\n    r.SLAT = torch.where(\n        dvs_mask.bool(),\n        torch.where(\n            is_lai_exp &amp; (r.GRLV &gt; self._epsilon), GLA / (r.GRLV + self._epsilon), r.SLAT\n        ),\n        self._zero,\n    )\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.leaf_dynamics.WOFOST_Leaf_Dynamics.integrate","title":"integrate","text":"<pre><code>integrate(day: date, delt=1.0) -&gt; None\n</code></pre> <p>Integrate the leaf dynamics state variables.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>delt</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The time step for integration. Defaults to 1.0.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/leaf_dynamics.py</code> <pre><code>@prepare_states\ndef integrate(self, day: datetime.date, delt=1.0) -&gt; None:\n    \"\"\"Integrate the leaf dynamics state variables.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        delt (float, optional): The time step for integration. Defaults to 1.0.\n    \"\"\"\n    # TODO check if DVS &lt; 0 and skip integration needed\n    rates = self.rates\n    states = self.states\n\n    # --------- leave death ---------\n    tLV = states.LV.clone()\n    tSLA = states.SLA.clone()\n    tLVAGE = states.LVAGE.clone()\n    tDRLV = _broadcast_to(rates.DRLV, tLV.shape, dtype=self.dtype, device=self.device)\n\n    # Leaf death is imposed on leaves from the oldest ones.\n    # Calculate the cumulative sum of weights after leaf death, and\n    # find out which leaf classes are dead (negative weights)\n    weight_cumsum = tLV.cumsum(dim=-1) - tDRLV\n    is_alive = weight_cumsum &gt;= 0\n\n    # Adjust value of oldest leaf class, i.e. the first non-zero\n    # weight along the time axis (the last dimension).\n    # Cast argument to int because torch.argmax requires it to be numeric\n    idx_oldest = torch.argmax(is_alive.type(torch.int), dim=-1, keepdim=True).to(\n        device=self.device\n    )\n    new_biomass = torch.take_along_dim(weight_cumsum, indices=idx_oldest, dim=-1)\n    tLV = torch.scatter(tLV, dim=-1, index=idx_oldest, src=new_biomass)\n\n    # Integration of physiological age\n    # Zero out all dead leaf classes\n    # NOTE: conditional statements do not allow for the gradient to be\n    # tracked through the condition. Thus, the gradient with respect to\n    # parameters that contribute to `is_alive` are expected to be incorrect.\n    tLV = torch.where(is_alive, tLV, 0.0)\n    tLVAGE = tLVAGE + rates.FYSAGE.unsqueeze(-1)\n    tLVAGE = torch.where(is_alive, tLVAGE, 0.0)\n    tSLA = torch.where(is_alive, tSLA, 0.0)\n\n    # --------- leave growth ---------\n    idx = int((day - self.START_DATE).days / delt)\n    tLV[..., idx] = rates.GRLV\n    tSLA[..., idx] = rates.SLAT\n    tLVAGE[..., idx] = 0.0\n\n    # calculation of new leaf area\n    states.LASUM = torch.sum(tLV * tSLA, dim=-1)\n    states.LAI = self._calc_LAI()\n    states.LAIMAX = torch.maximum(states.LAI, states.LAIMAX)\n\n    # exponential growth curve\n    states.LAIEXP = states.LAIEXP + rates.GLAIEX\n\n    # Update leaf biomass states\n    states.WLV = torch.sum(tLV, dim=-1)\n    states.DWLV = states.DWLV + rates.DRLV\n    states.TWLV = states.WLV + states.DWLV\n\n    # Store final leaf biomass deques\n    self.states.LV = tLV\n    self.states.SLA = tSLA\n    self.states.LVAGE = tLVAGE\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics","title":"diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Root biomass dynamics and rooting depth.</p> <p>Root growth and root biomass dynamics in WOFOST are separate processes, with the only exception that root growth stops when no more biomass is sent to the root system.</p> <p>Root biomass increase results from the assimilates partitioned to the root system. Root death is defined as the current root biomass multiplied by a relative death rate (<code>RDRRTB</code>). The latter as a function of the development stage (<code>DVS</code>).</p> <p>Increase in root depth is a simple linear expansion over time until the maximum rooting depth (<code>RDM</code>) is reached.</p> <p>Simulation parameters</p> Name Description Type Unit RDI Initial rooting depth SCr cm RRI Daily increase in rooting depth SCr cm day\u207b\u00b9 RDMCR Maximum rooting depth of the crop SCR cm RDMSOL Maximum rooting depth of the soil SSo cm TDWI Initial total crop dry weight SCr kg ha\u207b\u00b9 IAIRDU Presence of air ducts in the root (1) or not (0) SCr - RDRRTB Relative death rate of roots as a function of development stage TCr - <p>State variables</p> Name Description Pbl Unit RD Current rooting depth Y cm RDM Maximum attainable rooting depth at the minimum of the soil and crop maximum rooting depth N cm WRT Weight of living roots Y kg ha\u207b\u00b9 DWRT Weight of dead roots N kg ha\u207b\u00b9 TWRT Total weight of roots Y kg ha\u207b\u00b9 <p>Rate variables</p> Name Description Pbl Unit RR Growth rate root depth N cm GRRT Growth rate root biomass N kg ha\u207b\u00b9 d\u207b\u00b9 DRRT Death rate root biomass N kg ha\u207b\u00b9 d\u207b\u00b9 GWRT Net change in root biomass N kg ha\u207b\u00b9 d\u207b\u00b9 <p>Signals send or handled</p> <p>None</p> <p>External dependencies:</p> Name Description Provided by Unit DVS Crop development stage DVS_Phenology - DMI Total dry matter increase CropSimulation kg ha\u207b\u00b9 d\u207b\u00b9 FR Fraction biomass to roots DVS_Partitioning - <p>Outputs:</p> Name Description Provided by Unit RD Current rooting depth Y cm TWRT Total weight of roots Y kg ha\u207b\u00b9 <p>Gradient mapping (which parameters have a gradient):</p> Output Parameters influencing it RD RDI, RRI, RDMCR, RDMSOL TWRT TDWI, RDRRTB <p>[!NOTE] Notice that the gradient \u2202TWRT/\u2202RDRRTB is zero.</p> <p>IMPORTANT NOTICE</p> <p>Currently root development is linear and depends only on the fraction of assimilates send to the roots (FR) and not on the amount of assimilates itself. This means that roots also grow through the winter when there is no assimilation due to low temperatures. There has been a discussion to change this behaviour and make root growth dependent on the assimilates send to the roots: so root growth stops when there are no assimilates available for growth.</p> <p>Finally, we decided not to change the root model and keep the original WOFOST approach because of the following reasons: - A dry top layer in the soil could create a large drought stress that reduces the   assimilates to zero. In this situation the roots would not grow if dependent on the   assimilates, while water is available in the zone just below the root zone. Therefore   a dependency on the amount of assimilates could create model instability in dry   conditions (e.g. Southern-Mediterranean, etc.). - Other solutions to alleviate the problem above were explored: only put this limitation   after a certain development stage, putting a dependency on soil moisture levels in the   unrooted soil compartment. All these solutions were found to introduce arbitrary   parameters that have no clear explanation. Therefore all proposed solutions were discarded.</p> <p>We conclude that our current knowledge on root development is insufficient to propose a better and more biophysical approach to root development in WOFOST.</p> <p>Methods:</p> <ul> <li> <code>initialize</code>             \u2013              <p>Initialize the model.</p> </li> <li> <code>calc_rates</code>             \u2013              <p>Calculate the rates of change of the state variables.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate the state variables using the rates of change.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>device</code>           \u2013            <p>Get device from ComputeConfig.</p> </li> <li> <code>dtype</code>           \u2013            <p>Get dtype from ComputeConfig.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.device","title":"device  <code>property</code>","text":"<pre><code>device\n</code></pre> <p>Get device from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Get dtype from ComputeConfig.</p>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.initialize","title":"initialize","text":"<pre><code>initialize(day: date, kiosk: VariableKiosk, parvalues: ParameterProvider) -&gt; None\n</code></pre> <p>Initialize the model.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>)           \u2013            <p>The starting date of the simulation.</p> </li> <li> <code>kiosk</code>               (<code>VariableKiosk</code>)           \u2013            <p>A container for registering and publishing (internal and external) state variables. See PCSE documentation for details.</p> </li> <li> <code>parvalues</code>               (<code>ParameterProvider</code>)           \u2013            <p>A dictionary-like container holding all parameter sets (crop, soil, site) as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/root_dynamics.py</code> <pre><code>def initialize(\n    self, day: datetime.date, kiosk: VariableKiosk, parvalues: ParameterProvider\n) -&gt; None:\n    \"\"\"Initialize the model.\n\n    Args:\n        day (datetime.date): The starting date of the simulation.\n        kiosk (VariableKiosk): A container for registering and publishing\n            (internal and external) state variables. See PCSE documentation for\n            details.\n        parvalues (ParameterProvider): A dictionary-like container holding\n            all parameter sets (crop, soil, site) as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    self.kiosk = kiosk\n    self.params = self.Parameters(parvalues)\n    self.rates = self.RateVariables(kiosk, publish=[\"DRRT\", \"GRRT\"])\n\n    # INITIAL STATES\n    params = self.params\n    self.params_shape = _get_params_shape(params)\n    shape = self.params_shape\n\n    # Initial root depth states\n    RDI = _broadcast_to(params.RDI, shape, dtype=self.dtype, device=self.device)\n    RDMCR = _broadcast_to(params.RDMCR, shape, dtype=self.dtype, device=self.device)\n    RDMSOL = _broadcast_to(params.RDMSOL, shape, dtype=self.dtype, device=self.device)\n\n    rdmax = torch.maximum(RDI, torch.minimum(RDMCR, RDMSOL))\n    RDM = rdmax\n    RD = RDI\n\n    # Initial root biomass states\n    TDWI = _broadcast_to(params.TDWI, shape, dtype=self.dtype, device=self.device)\n    FR = _broadcast_to(self.kiosk[\"FR\"], shape, dtype=self.dtype, device=self.device)\n    WRT = TDWI * FR\n    DWRT = torch.zeros(shape, dtype=self.dtype, device=self.device)\n    TWRT = WRT + DWRT\n\n    self.states = self.StateVariables(\n        kiosk, publish=[\"RD\", \"WRT\", \"TWRT\"], RD=RD, RDM=RDM, WRT=WRT, DWRT=DWRT, TWRT=TWRT\n    )\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.calc_rates","title":"calc_rates","text":"<pre><code>calc_rates(day: date = None, drv: WeatherDataContainer = None) -&gt; None\n</code></pre> <p>Calculate the rates of change of the state variables.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>, default:                   <code>None</code> )           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>drv</code>               (<code>WeatherDataContainer</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary-like container holding weather data elements as key/value. The values are arrays or scalars. See PCSE documentation for details.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/root_dynamics.py</code> <pre><code>@prepare_rates\ndef calc_rates(self, day: datetime.date = None, drv: WeatherDataContainer = None) -&gt; None:\n    \"\"\"Calculate the rates of change of the state variables.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        drv (WeatherDataContainer, optional): A dictionary-like container holding\n            weather data elements as key/value. The values are\n            arrays or scalars. See PCSE documentation for details.\n    \"\"\"\n    p = self.params\n    r = self.rates\n    s = self.states\n    k = self.kiosk\n\n    # If DVS &lt; 0, the crop has not yet emerged, so we zerofy the rates using mask.\n    # Make a mask (0 if DVS &lt; 0, 1 if DVS &gt;= 0)\n    DVS = _broadcast_to(k[\"DVS\"], self.params_shape, dtype=self.dtype, device=self.device)\n    dvs_mask = (DVS &gt;= 0).to(dtype=self.dtype)\n\n    # Increase in root biomass\n    FR = _broadcast_to(k[\"FR\"], self.params_shape, dtype=self.dtype, device=self.device)\n    DMI = _broadcast_to(k[\"DMI\"], self.params_shape, dtype=self.dtype, device=self.device)\n    RDRRTB = p.RDRRTB.to(device=self.device, dtype=self.dtype)\n\n    r.GRRT = dvs_mask * FR * DMI\n    r.DRRT = dvs_mask * s.WRT * RDRRTB(DVS)\n    r.GWRT = r.GRRT - r.DRRT\n\n    # Increase in root depth\n    RRI = _broadcast_to(p.RRI, self.params_shape, dtype=self.dtype, device=self.device)\n    r.RR = dvs_mask * torch.minimum((s.RDM - s.RD), RRI)\n\n    # Do not let the roots growth if partioning to the roots\n    # (variable FR) is zero.\n    mask = (FR &gt; 0.0).to(dtype=self.dtype)\n    r.RR = r.RR * mask * dvs_mask\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.crop.root_dynamics.WOFOST_Root_Dynamics.integrate","title":"integrate","text":"<pre><code>integrate(day: date = None, delt=1.0) -&gt; None\n</code></pre> <p>Integrate the state variables using the rates of change.</p> <p>Parameters:</p> <ul> <li> <code>day</code>               (<code>date</code>, default:                   <code>None</code> )           \u2013            <p>The current date of the simulation.</p> </li> <li> <code>delt</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The time step for integration. Defaults to 1.0.</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/crop/root_dynamics.py</code> <pre><code>@prepare_states\ndef integrate(self, day: datetime.date = None, delt=1.0) -&gt; None:\n    \"\"\"Integrate the state variables using the rates of change.\n\n    Args:\n        day (datetime.date, optional): The current date of the simulation.\n        delt (float, optional): The time step for integration. Defaults to 1.0.\n    \"\"\"\n    rates = self.rates\n    states = self.states\n\n    # Dry weight of living roots\n    states.WRT = states.WRT + rates.GWRT\n\n    # Dry weight of dead roots\n    states.DWRT = states.DWRT + rates.DRRT\n\n    # Total weight dry + living roots\n    states.TWRT = states.WRT + states.DWRT\n\n    # New root depth\n    states.RD = states.RD + rates.RR\n</code></pre>"},{"location":"api_reference/#utility-under-development","title":"Utility (under development)","text":""},{"location":"api_reference/#diffwofost.physical_models.config.Configuration","title":"diffwofost.physical_models.config.Configuration  <code>dataclass</code>","text":"<pre><code>Configuration(CROP: type[SimulationObject], SOIL: type[SimulationObject] | None = None, AGROMANAGEMENT: type[AncillaryObject] = AgroManager, OUTPUT_VARS: list = list(), SUMMARY_OUTPUT_VARS: list = list(), TERMINAL_OUTPUT_VARS: list = list(), OUTPUT_INTERVAL: str = 'daily', OUTPUT_INTERVAL_DAYS: int = 1, OUTPUT_WEEKDAY: int = 0, model_config_file: str | Path | None = None, description: str | None = None)\n</code></pre> <p>Class to store model configuration from a PCSE configuration files.</p> <p>Methods:</p> <ul> <li> <code>from_pcse_config_file</code>             \u2013              <p>Load the model configuration from a PCSE configuration file.</p> </li> <li> <code>update_output_variable_lists</code>             \u2013              <p>Updates the lists of output variables that are defined in the configuration file.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.config.Configuration.from_pcse_config_file","title":"from_pcse_config_file  <code>classmethod</code>","text":"<pre><code>from_pcse_config_file(filename: str | Path) -&gt; Self\n</code></pre> <p>Load the model configuration from a PCSE configuration file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | Path</code>)           \u2013            <p>Path to the configuraiton file. The path is first interpreted with respect to the current working directory and, if not found, it will then be interpreted with respect to the <code>conf</code> folder in the PCSE package.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Configuration</code> (              <code>Self</code> )          \u2013            <p>Model configuration instance</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>if the configuraiton file does not exist</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>if parsing the configuration file fails</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>@classmethod\ndef from_pcse_config_file(cls, filename: str | Path) -&gt; Self:\n    \"\"\"Load the model configuration from a PCSE configuration file.\n\n    Args:\n        filename (str | pathlib.Path): Path to the configuraiton file. The path is first\n            interpreted with respect to the current working directory and, if not found, it will\n            then be interpreted with respect to the `conf` folder in the PCSE package.\n\n    Returns:\n        Configuration: Model configuration instance\n\n    Raises:\n        FileNotFoundError: if the configuraiton file does not exist\n        RuntimeError: if parsing the configuration file fails\n    \"\"\"\n    config = {}\n\n    path = Path(filename)\n    if path.is_absolute() or path.is_file():\n        model_config_file = path\n    else:\n        pcse_dir = Path(pcse.__path__[0])\n        model_config_file = pcse_dir / \"conf\" / path\n    model_config_file = model_config_file.resolve()\n\n    # check that configuration file exists\n    if not model_config_file.exists():\n        msg = f\"PCSE model configuration file does not exist: {model_config_file.name}\"\n        raise FileNotFoundError(msg)\n    # store for later use\n    config[\"model_config_file\"] = model_config_file\n\n    # Load file using execfile\n    try:\n        loc = {}\n        bytecode = compile(open(model_config_file).read(), model_config_file, \"exec\")\n        exec(bytecode, {}, loc)\n    except Exception as e:\n        msg = f\"Failed to load configuration from file {model_config_file}\"\n        raise RuntimeError(msg) from e\n\n    # Add the descriptive header for later use\n    if \"__doc__\" in loc:\n        desc = loc.pop(\"__doc__\")\n        if len(desc) &gt; 0:\n            description = desc\n            if description[-1] != \"\\n\":\n                description += \"\\n\"\n        config[\"description\"] = description\n\n    # Loop through the attributes in the configuration file\n    for key, value in loc.items():\n        if key.isupper():\n            config[key] = value\n    return cls(**config)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.config.Configuration.update_output_variable_lists","title":"update_output_variable_lists","text":"<pre><code>update_output_variable_lists(output_vars: str | list | tuple | set | None = None, summary_vars: str | list | tuple | set | None = None, terminal_vars: str | list | tuple | set | None = None)\n</code></pre> <p>Updates the lists of output variables that are defined in the configuration file.</p> <p>This is useful because sometimes you want the flexibility to get access to an additional model variable which is not in the standard list of variables defined in the model configuration file. The more elegant way is to define your own configuration file, but this adds some flexibility particularly for use in jupyter notebooks and exploratory analysis.</p> <p>Note that there is a different behaviour given the type of the variable provided. List and string inputs will extend the list of variables, while set/tuple inputs will replace the current list.</p> <p>Parameters:</p> <ul> <li> <code>output_vars</code>               (<code>str | list | tuple | set | None</code>, default:                   <code>None</code> )           \u2013            <p>the variable names to add/replace for the OUTPUT_VARS configuration variable</p> </li> <li> <code>summary_vars</code>               (<code>str | list | tuple | set | None</code>, default:                   <code>None</code> )           \u2013            <p>the variable names to add/replace for the SUMMARY_OUTPUT_VARS configuration variable</p> </li> <li> <code>terminal_vars</code>               (<code>str | list | tuple | set | None</code>, default:                   <code>None</code> )           \u2013            <p>the variable names to add/replace for the TERMINAL_OUTPUT_VARS configuration variable</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if the type of the input arguments is not recognized</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>def update_output_variable_lists(\n    self,\n    output_vars: str | list | tuple | set | None = None,\n    summary_vars: str | list | tuple | set | None = None,\n    terminal_vars: str | list | tuple | set | None = None,\n):\n    \"\"\"Updates the lists of output variables that are defined in the configuration file.\n\n    This is useful because sometimes you want the flexibility to get access to an additional\n    model variable which is not in the standard list of variables defined in the model\n    configuration file. The more elegant way is to define your own configuration file, but this\n    adds some flexibility particularly for use in jupyter notebooks and exploratory analysis.\n\n    Note that there is a different behaviour given the type of the variable provided. List and\n    string inputs will extend the list of variables, while set/tuple inputs will replace the\n    current list.\n\n    Args:\n        output_vars: the variable names to add/replace for the OUTPUT_VARS configuration\n            variable\n        summary_vars: the variable names to add/replace for the SUMMARY_OUTPUT_VARS\n            configuration variable\n        terminal_vars: the variable names to add/replace for the TERMINAL_OUTPUT_VARS\n            configuration variable\n\n    Raises:\n        TypeError: if the type of the input arguments is not recognized\n    \"\"\"\n    config_varnames = [\"OUTPUT_VARS\", \"SUMMARY_OUTPUT_VARS\", \"TERMINAL_OUTPUT_VARS\"]\n    for varitems, config_varname in zip(\n        [output_vars, summary_vars, terminal_vars], config_varnames, strict=True\n    ):\n        if varitems is None:\n            continue\n        else:\n            if isinstance(varitems, str):  # A string: we extend the current list\n                getattr(self, config_varname).extend(varitems.split())\n            elif isinstance(varitems, list):  # a list: we extend the current list\n                getattr(self, config_varname).extend(varitems)\n            elif isinstance(varitems, tuple | set):  # tuple/set we replace the current list\n                attr = getattr(self, config_varname)\n                attr.clear()\n                attr.extend(list(varitems))\n            else:\n                msg = f\"Unrecognized input for `output_vars` to engine(): {output_vars}\"\n                raise TypeError(msg)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.config.ComputeConfig","title":"diffwofost.physical_models.config.ComputeConfig","text":"<p>Central configuration for device and dtype settings.</p> <p>This class provides a centralized way to control PyTorch device and dtype settings across all simulation objects in diffWOFOST. Instead of setting device and dtype individually for each class, use this central configuration to apply settings globally.</p> <p>Default Behavior:</p> <ul> <li>Device: Automatically defaults to 'cuda' if available, otherwise 'cpu'</li> <li>Dtype: Defaults to torch.float64</li> </ul> <p>Basic Usage:</p> <pre><code>&gt;&gt;&gt; from diffwofost.physical_models.config import ComputeConfig\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Set device to CPU\n&gt;&gt;&gt; ComputeConfig.set_device('cpu')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or use a torch.device object\n&gt;&gt;&gt; ComputeConfig.set_device(torch.device('cuda'))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Set dtype to float32\n&gt;&gt;&gt; ComputeConfig.set_dtype(torch.float32)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get current settings\n&gt;&gt;&gt; device = ComputeConfig.get_device()  # Returns: torch.device('cpu')\n&gt;&gt;&gt; dtype = ComputeConfig.get_dtype()    # Returns: torch.float32\n</code></pre> <p>Using with Simulation Objects:</p> <p>All simulation objects (e.g., WOFOST_Leaf_Dynamics, WOFOST_Phenology) automatically use the settings from ComputeConfig. No changes needed to instantiation code:</p> <pre><code>&gt;&gt;&gt; from diffwofost.physical_models.config import ComputeConfig\n&gt;&gt;&gt; from diffwofost.physical_models.crop.leaf_dynamics import WOFOST_Leaf_Dynamics\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Set global compute settings\n&gt;&gt;&gt; ComputeConfig.set_device('cuda')\n&gt;&gt;&gt; ComputeConfig.set_dtype(torch.float32)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Instantiate objects - they automatically use global settings\n&gt;&gt;&gt; leaf_dynamics = WOFOST_Leaf_Dynamics()\n</code></pre> <p>Switching Between Devices:</p> <p>Useful for switching between GPU training and CPU evaluation:</p> <pre><code>&gt;&gt;&gt; # Train on GPU\n&gt;&gt;&gt; ComputeConfig.set_device('cuda')\n&gt;&gt;&gt; ComputeConfig.set_dtype(torch.float32)\n&gt;&gt;&gt; # ... run training ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Evaluate on CPU\n&gt;&gt;&gt; ComputeConfig.set_device('cpu')\n&gt;&gt;&gt; ComputeConfig.set_dtype(torch.float64)\n&gt;&gt;&gt; # ... run evaluation ...\n</code></pre> <p>Resetting to Defaults:</p> <pre><code>&gt;&gt;&gt; ComputeConfig.reset_to_defaults()\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_device</code>             \u2013              <p>Get the current device setting.</p> </li> <li> <code>set_device</code>             \u2013              <p>Set the device to use for tensor operations.</p> </li> <li> <code>get_dtype</code>             \u2013              <p>Get the current dtype setting.</p> </li> <li> <code>set_dtype</code>             \u2013              <p>Set the dtype to use for tensor creation.</p> </li> <li> <code>reset_to_defaults</code>             \u2013              <p>Reset device and dtype to their default values.</p> </li> </ul>"},{"location":"api_reference/#diffwofost.physical_models.config.ComputeConfig.get_device","title":"get_device  <code>classmethod</code>","text":"<pre><code>get_device() -&gt; device\n</code></pre> <p>Get the current device setting.</p> <p>Returns:</p> <ul> <li> <code>device</code>           \u2013            <p>torch.device: The current device (cuda or cpu)</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>@classmethod\ndef get_device(cls) -&gt; torch.device:\n    \"\"\"Get the current device setting.\n\n    Returns:\n        torch.device: The current device (cuda or cpu)\n    \"\"\"\n    cls._initialize_defaults()\n    return cls._device\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.config.ComputeConfig.set_device","title":"set_device  <code>classmethod</code>","text":"<pre><code>set_device(device: str | device) -&gt; None\n</code></pre> <p>Set the device to use for tensor operations.</p> <p>Parameters:</p> <ul> <li> <code>device</code>               (<code>str | device</code>)           \u2013            <p>Device to use ('cuda', 'cpu', or torch.device object)</p> </li> </ul> Example <p>ComputeConfig.set_device('cuda') ComputeConfig.set_device(torch.device('cpu'))</p> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>@classmethod\ndef set_device(cls, device: str | torch.device) -&gt; None:\n    \"\"\"Set the device to use for tensor operations.\n\n    Args:\n        device (str | torch.device): Device to use ('cuda', 'cpu', or torch.device object)\n\n    Example:\n        &gt;&gt;&gt; ComputeConfig.set_device('cuda')\n        &gt;&gt;&gt; ComputeConfig.set_device(torch.device('cpu'))\n    \"\"\"\n    if isinstance(device, str):\n        cls._device = torch.device(device)\n    else:\n        cls._device = device\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.config.ComputeConfig.get_dtype","title":"get_dtype  <code>classmethod</code>","text":"<pre><code>get_dtype() -&gt; dtype\n</code></pre> <p>Get the current dtype setting.</p> <p>Returns:</p> <ul> <li> <code>dtype</code>           \u2013            <p>torch.dtype: The current dtype (e.g., torch.float32, torch.float64)</p> </li> </ul> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>@classmethod\ndef get_dtype(cls) -&gt; torch.dtype:\n    \"\"\"Get the current dtype setting.\n\n    Returns:\n        torch.dtype: The current dtype (e.g., torch.float32, torch.float64)\n    \"\"\"\n    cls._initialize_defaults()\n    return cls._dtype\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.config.ComputeConfig.set_dtype","title":"set_dtype  <code>classmethod</code>","text":"<pre><code>set_dtype(dtype: dtype) -&gt; None\n</code></pre> <p>Set the dtype to use for tensor creation.</p> <p>Parameters:</p> <ul> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>PyTorch dtype (torch.float32, torch.float64, etc.)</p> </li> </ul> Example <p>ComputeConfig.set_dtype(torch.float32)</p> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>@classmethod\ndef set_dtype(cls, dtype: torch.dtype) -&gt; None:\n    \"\"\"Set the dtype to use for tensor creation.\n\n    Args:\n        dtype (torch.dtype): PyTorch dtype (torch.float32, torch.float64, etc.)\n\n    Example:\n        &gt;&gt;&gt; ComputeConfig.set_dtype(torch.float32)\n    \"\"\"\n    cls._dtype = dtype\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.config.ComputeConfig.reset_to_defaults","title":"reset_to_defaults  <code>classmethod</code>","text":"<pre><code>reset_to_defaults() -&gt; None\n</code></pre> <p>Reset device and dtype to their default values.</p> Source code in <code>src/diffwofost/physical_models/config.py</code> <pre><code>@classmethod\ndef reset_to_defaults(cls) -&gt; None:\n    \"\"\"Reset device and dtype to their default values.\"\"\"\n    cls._device = None\n    cls._dtype = None\n    cls._initialize_defaults()\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.engine.Engine","title":"diffwofost.physical_models.engine.Engine","text":"<pre><code>Engine(parameterprovider, weatherdataprovider, agromanagement, config: str | Path | Configuration)\n</code></pre> <p>               Bases: <code>Engine</code></p> Source code in <code>src/diffwofost/physical_models/engine.py</code> <pre><code>def __init__(\n    self,\n    parameterprovider,\n    weatherdataprovider,\n    agromanagement,\n    config: str | Path | Configuration,\n):\n    BaseEngine.__init__(self)\n\n    # If a path is given, load the model configuration from a PCSE config file\n    if isinstance(config, str | Path):\n        self.mconf = Configuration.from_pcse_config_file(config)\n    else:\n        self.mconf = config\n\n    self.parameterprovider = parameterprovider\n\n    # Variable kiosk for registering and publishing variables\n    self.kiosk = VariableKiosk()\n\n    # Placeholder for variables to be saved during a model run\n    self._saved_output = []\n    self._saved_summary_output = []\n    self._saved_terminal_output = {}\n\n    # register handlers for starting/finishing the crop simulation, for\n    # handling output and terminating the system\n    self._connect_signal(self._on_CROP_START, signal=signals.crop_start)\n    self._connect_signal(self._on_CROP_FINISH, signal=signals.crop_finish)\n    self._connect_signal(self._on_OUTPUT, signal=signals.output)\n    self._connect_signal(self._on_TERMINATE, signal=signals.terminate)\n\n    # Component for agromanagement\n    self.agromanager = self.mconf.AGROMANAGEMENT(self.kiosk, agromanagement)\n    start_date = self.agromanager.start_date\n    end_date = self.agromanager.end_date\n\n    # Timer: starting day, final day and model output\n    self.timer = Timer(self.kiosk, start_date, end_date, self.mconf)\n    self.day, _ = self.timer()\n\n    # Driving variables\n    self.weatherdataprovider = weatherdataprovider\n    self.drv = self._get_driving_variables(self.day)\n\n    # Component for simulation of soil processes\n    if self.mconf.SOIL is not None:\n        self.soil = self.mconf.SOIL(self.day, self.kiosk, parameterprovider)\n\n    # Call AgroManagement module for management actions at initialization\n    self.agromanager(self.day, self.drv)\n\n    # Calculate initial rates\n    self.calc_rates(self.day, self.drv)\n</code></pre>"},{"location":"api_reference/#diffwofost.physical_models.utils.EngineTestHelper","title":"diffwofost.physical_models.utils.EngineTestHelper","text":"<pre><code>EngineTestHelper(parameterprovider, weatherdataprovider, agromanagement, config, external_states=None, device=None, dtype=None)\n</code></pre> <p>               Bases: <code>Engine</code></p> <p>An engine which is purely for running the YAML unit tests.</p> Source code in <code>src/diffwofost/physical_models/utils.py</code> <pre><code>def __init__(\n    self,\n    parameterprovider,\n    weatherdataprovider,\n    agromanagement,\n    config,\n    external_states=None,\n    device=None,\n    dtype=None,\n):\n    BaseEngine.__init__(self)\n\n    # If a path is given, load the model configuration from a PCSE config file\n    if isinstance(config, str | Path):\n        self.mconf = Configuration.from_pcse_config_file(config)\n    else:\n        self.mconf = config\n\n    self.parameterprovider = parameterprovider\n\n    # Configure device and dtype on crop module class if it supports them\n    if hasattr(self.mconf.CROP, \"device\") and device is not None:\n        self.mconf.CROP.device = device\n    if hasattr(self.mconf.CROP, \"dtype\") and dtype is not None:\n        self.mconf.CROP.dtype = dtype\n\n    # Variable kiosk for registering and publishing variables\n    self.kiosk = VariableKioskTestHelper(external_states)\n\n    # Placeholder for variables to be saved during a model run\n    self._saved_output = list()\n    self._saved_summary_output = list()\n    self._saved_terminal_output = dict()\n\n    # register handlers for starting/finishing the crop simulation, for\n    # handling output and terminating the system\n    self._connect_signal(self._on_CROP_START, signal=signals.crop_start)\n    self._connect_signal(self._on_CROP_FINISH, signal=signals.crop_finish)\n    self._connect_signal(self._on_OUTPUT, signal=signals.output)\n    self._connect_signal(self._on_TERMINATE, signal=signals.terminate)\n\n    # Component for agromanagement\n    self.agromanager = self.mconf.AGROMANAGEMENT(self.kiosk, agromanagement)\n    start_date = self.agromanager.start_date\n    end_date = self.agromanager.end_date\n\n    # Timer: starting day, final day and model output\n    self.timer = Timer(self.kiosk, start_date, end_date, self.mconf)\n    self.day, delt = self.timer()\n    # Update external states in the kiosk\n    self.kiosk(self.day)\n\n    # Driving variables\n    self.weatherdataprovider = weatherdataprovider\n    self.drv = self._get_driving_variables(self.day)\n\n    # Component for simulation of soil processes\n    if self.mconf.SOIL is not None:\n        self.soil = self.mconf.SOIL(self.day, self.kiosk, parameterprovider)\n\n    # Call AgroManagement module for management actions at initialization\n    self.agromanager(self.day, self.drv)\n\n    # Calculate initial rates\n    self.calc_rates(self.day, self.drv)\n</code></pre>"},{"location":"citation/","title":"Citation","text":"<p>If you use this software, please cite it using the zenodo DOI: https://doi.org/10.5281/zenodo.17474960.</p>"},{"location":"developer_guide/","title":"Developer guide","text":"<p>If you are a developer wanting to contribute to the diffwofost package, this guide will help you get started. First check out the contribution guidelines in Contributing guide and the Project setup to get familiar with the package structure and development practices.</p>"},{"location":"developer_guide/#installation-in-development-mode","title":"Installation in development mode","text":"<p>To install the package in development mode, you need to clone the source code and install the package in development mode:</p> <pre><code>git clone https://github.com/WUR-AI/diffWOFOST.git\ncd diffWOFOST\npip install -e .[dev]  ## install with development dependencies\npip install -e .[docs]  ## install with documentation dependencies\n</code></pre>"},{"location":"developer_guide/#github-collaboration-workflow","title":"GitHub collaboration workflow","text":"<p>We use a GitHub collaboration workflow based on feature branches and pull requests. When starting adding a new feature or fixing a bug, create a new branch from <code>main</code> branch. When your changes are ready, create a pull request to merge your changes back into <code>main</code> branch. Make sure to ask for at least one review from another team member before merging your pull request.</p>"},{"location":"developer_guide/#running-the-tests","title":"Running the tests","text":"<ul> <li>Tests should be put in the <code>tests</code> folder.</li> <li>The testing framework used is PyTest</li> <li>The project uses GitHub action workflows   to automatically run tests on GitHub infrastructure against multiple Python   versions. Workflows can be found in <code>.github/workflows</code> directory.</li> <li>Relevant section in the   guide</li> <li>To run the tests locally, you need to make sure that you have installed the development dependencies as described in the Installation in development mode section. Then, inside the package directory, run:</li> </ul> <pre><code>pytest -v\n</code></pre> <p>to run all tests with verbose output. To run an individual test file, run:</p> <pre><code>pytest -v tests/test_my_module.py\n</code></pre>"},{"location":"developer_guide/#linters","title":"Linters","text":"<p>For linting and sorting imports we will use ruff. Running the linters requires an activated virtual environment with the development tools installed.</p> <pre><code># linter\nruff check .\n\n# linter with automatic fixing\nruff check . --fix\n\n# check formatting only\nruff format --check . --diff\n</code></pre>"},{"location":"developer_guide/#documentation-page","title":"Documentation page","text":"<ul> <li>Documentation should be put in the <code>docs/</code> directory.</li> <li>We recommend writing the documentation using Google style docstrings.</li> <li>The documentation is set up with the MkDocs.</li> <li><code>.mkdocs.yml</code> is the MkDocs configuration file. When MkDocs is building the documentation this package and its development dependencies are installed so the API reference can be rendered.</li> <li>Make sure you have installed the documentation dependencies as described in the Installation in development mode section. Then, inside the package directory, run:</li> </ul> <pre><code># Build the documentation\nmkdocs build\n\n# Preview the documentation\nmkdocs serve\n</code></pre> <p>Click on the link provided in the terminal to view the documentation page.</p>"},{"location":"developer_guide/#coding-style-conventions-and-code-quality","title":"Coding style conventions and code quality","text":"<ul> <li>Relevant section in the NLeSC guide.</li> </ul>"},{"location":"developer_guide/#continuous-code-quality","title":"Continuous code quality","text":"<p>Sonarcloud is used to perform quality analysis and code coverage report</p> <ul> <li><code>sonar-project.properties</code> is the SonarCloud configuration file</li> <li><code>.github/workflows/sonarcloud.yml</code> is the GitHub action workflow which performs the SonarCloud analysis</li> </ul>"},{"location":"examples/","title":"Example notebooks","text":""},{"location":"examples/#optimization-with-diffwofost","title":"Optimization with diffWOFOST","text":"<p>We provide an example notebook showing optimization of models' parameters with <code>diffWOFOST</code>. To get familiar with the concepts and implementation, check out <code>Introduction</code> in the documentation.</p> Model Open the notebook Access the source View the notebook Phenology Root dynamics Leaf dynamics <p>Note</p> <p>When calculating gradients, it is important to ensure that the predicted physical parameters are within realistic bounds regarding the crop and environmental conditions.</p> <p>Also, when calculating gradients of an output w.r.t. parameters, it would be good to know in advance how the parameters in a model influence the outputs. If a parameter has little to no influence on an output, the gradient of the output w.r.t the parameter will be close to zero, which may not provide useful information for optimization.</p>"},{"location":"examples/#computing-configuration","title":"Computing configuration","text":"<p>The object <code>ComputeConfig</code> provides a central configuration for PyTorch device and dtype settings across all simulation objects in diffWOFOST. Instead of setting device and dtype individually for each class, use this central configuration to apply settings globally.</p> <p>Default Behavior:</p> <ul> <li>Device: Automatically defaults to 'cuda' if available, otherwise 'cpu'</li> <li>Dtype: Defaults to torch.float64</li> </ul> <p>Basic Usage:</p> <pre><code>from diffwofost.physical_models.config import ComputeConfig\nimport torch\n# Set device to CPU\nComputeConfig.set_device('cpu')\n\n# Or use a torch.device object\nComputeConfig.set_device(torch.device('cuda'))\n\n# Set dtype to float32\nComputeConfig.set_dtype(torch.float32)\n\n# Get current settings\ndevice = ComputeConfig.get_device()  # Returns: torch.device('cpu')\ndtype = ComputeConfig.get_dtype()    # Returns: torch.float32\n</code></pre> <p>More info:</p> <p>See the ComputeConfig API reference for more details.</p>"},{"location":"installation/","title":"Installation","text":"<p>To install the package, use pip:</p> <pre><code>pip install diffwofost\n</code></pre> <p>if you want to run notebooks locally, you need to install <code>jupyterlab</code>:</p> <pre><code>pip install jupyterlab\n</code></pre> <p>If you are a contributor, clone the source code and install the package in development mode:</p> <pre><code>git clone https://github.com/WUR-AI/diffWOFOST.git\ncd diffWOFOST\npip install -e .[dev]\n</code></pre> <p>If you are a contributor, follow the instructions in the <code>How to Contribute</code> in the documentation.</p>"},{"location":"license/","title":"License","text":"<p>EUPL, Version 1.1</p> <p>Licensed under the EUPL, Version 1.1 or as soon they will be approved by the European Commission - subsequent versions of the EUPL (the \"Licence\").</p> <p>You may not use this work except in compliance with the Licence. You may obtain a copy of the Licence at:</p> <p>https://interoperable-europe.ec.europa.eu/licence/european-union-public-licence-version-11-eupl Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p> <p>See the Licence for the specific language governing permissions and limitations under the Licence.</p>"},{"location":"project_setup/","title":"Project setup","text":"<p>Here we provide some details about the project setup. Most of the choices are explained in the Turing Way: Guide for Reproducible Research.</p>"},{"location":"project_setup/#repository-structure","title":"Repository structure","text":"<p>The repository has the following structure:</p> <pre><code>\u251c\u2500\u2500 .github/        # GitHub specific files such as workflows\n\u251c\u2500\u2500 docs/           # Documentation source files\n\u251c\u2500\u2500 my_package/     # Main package code\n\u251c\u2500\u2500 tests/          # Test code\n\u251c\u2500\u2500 .gitignore      # Git ignore file\n\u251c\u2500\u2500 CITATION.cff    # Citation file\n\u251c\u2500\u2500 LICENSE         # License file\n\u251c\u2500\u2500 README.md       # User documentation\n\u251c\u2500\u2500 pyproject.toml  # Project configuration file and dependencies\n\u251c\u2500\u2500 mkdocs.yml      # MkDocs configuration file\n</code></pre>"},{"location":"project_setup/#package-management-and-dependencies","title":"Package management and dependencies","text":"<p>You can use pip for installing dependencies and package management.</p> <ul> <li>Runtime dependencies should be added to <code>pyproject.toml</code> in the <code>dependencies</code>   list under <code>[project]</code>.</li> <li>Development dependencies, such as for testing or documentation, should be   added to <code>pyproject.toml</code> in one of the lists under   <code>[project.optional-dependencies]</code>.</li> </ul>"},{"location":"project_setup/#packagingone-command-install","title":"Packaging/One command install","text":"<p>You can distribute your code using PyPI. This can be done automatically using GitHub workflows, see <code>.github/</code>.</p>"},{"location":"project_setup/#package-version-number","title":"Package version number","text":"<ul> <li>We recommend using semantic versioning.</li> <li>For convenience, the package version is stored in a single place: <code>pyproject.toml</code>.</li> <li>Don't forget to update the version number before making a release! Also, update <code>__version__</code> variable in <code>diffwofost/__init__.py</code> to the    same version.</li> </ul>"},{"location":"project_setup/#citationcff","title":"CITATION.cff","text":"<ul> <li>To allow others to cite your software, add a <code>CITATION.cff</code> file</li> <li>It only makes sense to do this once there is something to cite (e.g., a software release with a DOI).</li> <li>Follow the Software Citation with CITATION.cff section in the Turing Way guide.</li> </ul>"},{"location":"project_setup/#code_of_conductmd","title":"CODE_OF_CONDUCT.md","text":"<ul> <li>Information about how to behave professionally</li> <li>To know more, read Turing Way guide on Code of Conduct</li> </ul>"},{"location":"project_setup/#contributingmd","title":"CONTRIBUTING.md","text":"<ul> <li>Information about how to contribute to this software package</li> <li>To know more, read Turing Way guide on Contributing</li> </ul>"},{"location":"references/","title":"References","text":"<p>Here are some useful references related to <code>WOFOST</code> and <code>PCSE</code>. If you want to cite the <code>diffWOFOST</code> package in your research, please use the software doi.</p> <ul> <li>WOFOST (WOrld FOod STudies)</li> <li>A gentle introduction to WOFOST</li> <li>PCSE/ WOFOST documentation</li> <li>Jupyter notebooks demonstrating the use of PCSE/WOFOST</li> <li>PCSE GitHub repository</li> <li>DeltaCrop project</li> </ul>"},{"location":"run_model/","title":"How to run a model","text":""},{"location":"run_model/#how-to-run-a-model-with-pcse","title":"How to run a model with PCSE","text":"<p>To get familiar with WOFOST models and how to run the models, we recommend to first check out the PCSE documentation and explore the notebooks 01 Getting Started with PCSE.ipynb and 02 Running with custom input data.ipynb .</p> <p>In a nutshell, we can run a model, for example, <code>leaf_dynamics</code> using diffWOFOST as:</p> <pre><code>from diffwofost.physical_models.utils import EngineTestHelper\nfrom diffwofost.physical_models.config import Configuration\nfrom diffwofost.physical_models.crop.leaf_dynamics import WOFOST_Leaf_Dynamics\n\n# create config\nleaf_dynamics_config = Configuration(\n    CROP=WOFOST_Leaf_Dynamics,\n    OUTPUT_VARS=[\"LAI\", \"TWLV\"],\n)\n\n# create the model\nmodel = EngineTestHelper(\n    crop_parameters_provider,  # this provides the crop parameters\n    weather_data_provider,\n    agromanagement_provider,\n    leaf_dynamics_config,  # this where the differentiable model is specified\n    external_states,  # any external states if needed\n)\n\n# run the simulation with a fixed time step of one day\nmodel.run_till_terminate()\n\n# get the output\nresults = model.get_output()\n</code></pre>"},{"location":"notebooks/optimization_leaf_dynamics/","title":"Optimization leaf dynamics","text":"Optimizing parameters in a WOFOST crop model using <code>diffWOFOST</code> <p>This Jupyter notebook demonstrates the optimization of parameters in a differentiable model using the <code>diffwofost</code> package. The package provides differentiable implementations of the WOFOST model and its associated sub-models. As <code>diffwofost</code> is under active development, this notebook focuses on <code>leaf_dynamics</code>.</p> <p>To enable these models to operate independently, certain state variables required by the model are supplied as \"external states\" derived from the test data. Also, at this stage, only a limited subset of model parameters has been made differentiable.</p> In\u00a0[\u00a0]: Copied! <pre># install diffwofost\n!pip install diffwofost\n</pre> # install diffwofost !pip install diffwofost In\u00a0[1]: Copied! <pre># ---- import libraries ----\nimport copy\nimport torch\nimport numpy\nimport yaml\nfrom pathlib import Path\nfrom diffwofost.physical_models.config import Configuration\nfrom diffwofost.physical_models.crop.leaf_dynamics import WOFOST_Leaf_Dynamics\nfrom diffwofost.physical_models.utils import EngineTestHelper\nfrom diffwofost.physical_models.utils import prepare_engine_input\nfrom diffwofost.physical_models.utils import get_test_data\n</pre> # ---- import libraries ---- import copy import torch import numpy import yaml from pathlib import Path from diffwofost.physical_models.config import Configuration from diffwofost.physical_models.crop.leaf_dynamics import WOFOST_Leaf_Dynamics from diffwofost.physical_models.utils import EngineTestHelper from diffwofost.physical_models.utils import prepare_engine_input from diffwofost.physical_models.utils import get_test_data In\u00a0[\u00a0]: Copied! <pre># --- run on CPU ------\nfrom diffwofost.physical_models.config import ComputeConfig\nComputeConfig.set_device('cpu')\n</pre> # --- run on CPU ------ from diffwofost.physical_models.config import ComputeConfig ComputeConfig.set_device('cpu') In\u00a0[2]: Copied! <pre># ---- disable a warning: this will be fixed in the future ----\nimport warnings\nwarnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\")\n</pre> # ---- disable a warning: this will be fixed in the future ---- import warnings warnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\") In\u00a0[3]: Copied! <pre>import urllib.request\n\nurl = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_leafdynamics_wofost72_01.yaml\"\nfilename = \"test_leafdynamics_wofost72_01.yaml\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> import urllib.request  url = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_leafdynamics_wofost72_01.yaml\" filename = \"test_leafdynamics_wofost72_01.yaml\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: test_leafdynamics_wofost72_01.yaml\n</pre> In\u00a0[4]: Copied! <pre># ---- Check the path to the files that are downloaded as explained above ----\ntest_data_path = \"test_leafdynamics_wofost72_01.yaml\"\n</pre> # ---- Check the path to the files that are downloaded as explained above ---- test_data_path = \"test_leafdynamics_wofost72_01.yaml\" In\u00a0[5]: Copied! <pre># ---- Here we read the test data and set some variables ----\ntest_data = get_test_data(test_data_path)\n(crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (\n    prepare_engine_input(test_data, [\"SPAN\", \"TDWI\", \"TBASE\", \"PERDL\", \"RGRLAI\"])\n)\n\nexpected_results = test_data[\"ModelResults\"]\nexpected_lai_twlv = torch.tensor(\n    [[float(item[\"LAI\"]), float(item[\"TWLV\"])] for item in expected_results], dtype=torch.float32\n).unsqueeze(0) # shape: [1, time_steps, 2]\n\n# ---- dont change this: in this config file we specified the diffrentiable version of leaf_dynamics ----\nleaf_dynamics_config = Configuration(\n    CROP=WOFOST_Leaf_Dynamics,\n    OUTPUT_VARS=[\"LAI\", \"TWLV\"],\n)\n</pre> # ---- Here we read the test data and set some variables ---- test_data = get_test_data(test_data_path) (crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (     prepare_engine_input(test_data, [\"SPAN\", \"TDWI\", \"TBASE\", \"PERDL\", \"RGRLAI\"]) )  expected_results = test_data[\"ModelResults\"] expected_lai_twlv = torch.tensor(     [[float(item[\"LAI\"]), float(item[\"TWLV\"])] for item in expected_results], dtype=torch.float32 ).unsqueeze(0) # shape: [1, time_steps, 2]  # ---- dont change this: in this config file we specified the diffrentiable version of leaf_dynamics ---- leaf_dynamics_config = Configuration(     CROP=WOFOST_Leaf_Dynamics,     OUTPUT_VARS=[\"LAI\", \"TWLV\"], ) In\u00a0[6]: Copied! <pre># ---- Adjust the values if needed  ----\nTDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.40)\nSPAN_MIN, SPAN_MAX, SPAN_INIT = (10.0, 60.0, 25.0)\n\n# ---- Helper for bounded parameters ----\nclass BoundedParameter(torch.nn.Module):\n    def __init__(self, low, high, init_value):\n        super().__init__()\n        self.low = low\n        self.high = high\n\n        # Normalize to [0, 1]\n        init_norm = (init_value - low) / (high - low)\n\n        # Parameter in raw logit space\n        self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))\n\n    def forward(self):\n        return self.low + (self.high - self.low) * torch.sigmoid(self.raw)\n</pre> # ---- Adjust the values if needed  ---- TDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.40) SPAN_MIN, SPAN_MAX, SPAN_INIT = (10.0, 60.0, 25.0)  # ---- Helper for bounded parameters ---- class BoundedParameter(torch.nn.Module):     def __init__(self, low, high, init_value):         super().__init__()         self.low = low         self.high = high          # Normalize to [0, 1]         init_norm = (init_value - low) / (high - low)          # Parameter in raw logit space         self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))      def forward(self):         return self.low + (self.high - self.low) * torch.sigmoid(self.raw)  <p>Another helper class is <code>OptDiffLeafDynamics</code> which is a subclass of <code>torch.nn.Module</code>. We use this class to wrap the <code>EngineTestHelper</code> function and make it easier to run the model <code>leaf_dynamic</code>.</p> In\u00a0[7]: Copied! <pre># ---- Wrap the model with torch.nn.Module----\nclass OptDiffLeafDynamics(torch.nn.Module):\n    def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, leaf_dynamics_config, external_states):\n        super().__init__()\n        self.crop_model_params_provider = crop_model_params_provider\n        self.weather_data_provider = weather_data_provider\n        self.agro_management_inputs = agro_management_inputs\n        self.config = leaf_dynamics_config\n        self.external_states = external_states\n\n        # bounded parameters\n        self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)\n        self.span = BoundedParameter(SPAN_MIN, SPAN_MAX, init_value=SPAN_INIT)\n\n    def forward(self):\n        # currently, copying is needed due to an internal issue in engine\n        crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)\n        external_states_ = copy.deepcopy(self.external_states)\n        \n        tdwi_val = self.tdwi()\n        span_val = self.span()\n        \n        # pass new value of parameters to the model\n        crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)\n        crop_model_params_provider_.set_override(\"SPAN\", span_val, check=False)\n\n        engine = EngineTestHelper(\n            crop_model_params_provider_,\n            self.weather_data_provider,\n            self.agro_management_inputs,\n            self.config,\n            external_states_,\n        )\n        engine.run_till_terminate()\n        results = engine.get_output()\n        \n        return torch.stack(\n            [torch.stack([item[\"LAI\"], item[\"TWLV\"]]) for item in results]\n        ).unsqueeze(0) # shape: [1, time_steps, 2]\n</pre> # ---- Wrap the model with torch.nn.Module---- class OptDiffLeafDynamics(torch.nn.Module):     def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, leaf_dynamics_config, external_states):         super().__init__()         self.crop_model_params_provider = crop_model_params_provider         self.weather_data_provider = weather_data_provider         self.agro_management_inputs = agro_management_inputs         self.config = leaf_dynamics_config         self.external_states = external_states          # bounded parameters         self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)         self.span = BoundedParameter(SPAN_MIN, SPAN_MAX, init_value=SPAN_INIT)      def forward(self):         # currently, copying is needed due to an internal issue in engine         crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)         external_states_ = copy.deepcopy(self.external_states)                  tdwi_val = self.tdwi()         span_val = self.span()                  # pass new value of parameters to the model         crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)         crop_model_params_provider_.set_override(\"SPAN\", span_val, check=False)          engine = EngineTestHelper(             crop_model_params_provider_,             self.weather_data_provider,             self.agro_management_inputs,             self.config,             external_states_,         )         engine.run_till_terminate()         results = engine.get_output()                  return torch.stack(             [torch.stack([item[\"LAI\"], item[\"TWLV\"]]) for item in results]         ).unsqueeze(0) # shape: [1, time_steps, 2] In\u00a0[8]: Copied! <pre># ----  Create model ---- \nopt_model = OptDiffLeafDynamics(\n    crop_model_params_provider,\n    weather_data_provider,\n    agro_management_inputs,\n    leaf_dynamics_config,\n    external_states,\n)\n</pre> # ----  Create model ----  opt_model = OptDiffLeafDynamics(     crop_model_params_provider,     weather_data_provider,     agro_management_inputs,     leaf_dynamics_config,     external_states, ) In\u00a0[9]: Copied! <pre># ----  Early stopping ---- \nbest_loss = float(\"inf\")\npatience = 10  # Number of steps to wait for improvement\npatience_counter = 0\nmin_delta = 1e-4 \n\n# ----  Optimizer ---- \noptimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)\n\n# ----  We use relative MAE as loss because there are two outputs with different untis ----  \ndenom = torch.mean(torch.abs(expected_lai_twlv), dim=1) \n\n# Training loop (example)\nfor step in range(101):\n    optimizer.zero_grad()\n    results = opt_model() \n    mae = torch.mean(torch.abs(results - expected_lai_twlv), dim=1)\n    rmae = mae / denom\n    loss = rmae.sum()  # example: relative mean absolute error\n    loss.backward()\n    optimizer.step()\n\n    print(f\"Step {step}, Loss {loss.item():.4f}, TDWI {opt_model.tdwi().item():.4f}, SPAN {opt_model.span().item():.4f}\")\n    # Early stopping logic\n    if loss.item() &lt; best_loss - min_delta:\n        best_loss = loss.item()\n        patience_counter = 0\n    else:\n        patience_counter += 1\n        if patience_counter &gt;= patience:\n            print(f\"Early stopping at step {step}\")\n            break\n</pre> # ----  Early stopping ----  best_loss = float(\"inf\") patience = 10  # Number of steps to wait for improvement patience_counter = 0 min_delta = 1e-4   # ----  Optimizer ----  optimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)  # ----  We use relative MAE as loss because there are two outputs with different untis ----   denom = torch.mean(torch.abs(expected_lai_twlv), dim=1)   # Training loop (example) for step in range(101):     optimizer.zero_grad()     results = opt_model()      mae = torch.mean(torch.abs(results - expected_lai_twlv), dim=1)     rmae = mae / denom     loss = rmae.sum()  # example: relative mean absolute error     loss.backward()     optimizer.step()      print(f\"Step {step}, Loss {loss.item():.4f}, TDWI {opt_model.tdwi().item():.4f}, SPAN {opt_model.span().item():.4f}\")     # Early stopping logic     if loss.item() &lt; best_loss - min_delta:         best_loss = loss.item()         patience_counter = 0     else:         patience_counter += 1         if patience_counter &gt;= patience:             print(f\"Early stopping at step {step}\")             break <pre>Step 0, Loss 0.2682, TDWI 0.4242, SPAN 26.0705\nStep 1, Loss 0.2400, TDWI 0.4485, SPAN 27.1814\nStep 2, Loss 0.2117, TDWI 0.4727, SPAN 28.3303\nStep 3, Loss 0.1790, TDWI 0.4962, SPAN 29.5140\nStep 4, Loss 0.1502, TDWI 0.5190, SPAN 30.7290\nStep 5, Loss 0.1148, TDWI 0.5351, SPAN 31.8314\nStep 6, Loss 0.0873, TDWI 0.5459, SPAN 32.8227\nStep 7, Loss 0.0633, TDWI 0.5525, SPAN 33.6916\nStep 8, Loss 0.0380, TDWI 0.5559, SPAN 34.4434\nStep 9, Loss 0.0164, TDWI 0.5564, SPAN 35.0537\nStep 10, Loss 0.0016, TDWI 0.5543, SPAN 35.2340\nStep 11, Loss 0.0050, TDWI 0.5500, SPAN 35.0621\nStep 12, Loss 0.0018, TDWI 0.5436, SPAN 34.6755\nStep 13, Loss 0.0109, TDWI 0.5356, SPAN 34.2452\nStep 14, Loss 0.0230, TDWI 0.5261, SPAN 33.8167\nStep 15, Loss 0.0341, TDWI 0.5152, SPAN 33.4017\nStep 16, Loss 0.0472, TDWI 0.5031, SPAN 33.0102\nStep 17, Loss 0.0559, TDWI 0.4950, SPAN 32.9639\nStep 18, Loss 0.0571, TDWI 0.4903, SPAN 33.1766\nStep 19, Loss 0.0519, TDWI 0.4888, SPAN 33.5989\nStep 20, Loss 0.0400, TDWI 0.4899, SPAN 34.1872\nEarly stopping at step 20\n</pre> In\u00a0[10]: Copied! <pre># ---- validate the results using test data ---- \nprint(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}, SPAN {crop_model_params_provider[\"SPAN\"].item():.4f}\")\n</pre> # ---- validate the results using test data ----  print(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}, SPAN {crop_model_params_provider[\"SPAN\"].item():.4f}\") <pre>Actual TDWI 0.5100, SPAN 35.0000\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/optimization_leaf_dynamics/#1-leaf-dynamics","title":"1. Leaf dynamics\u00b6","text":"<p>In this section, we will demonstrate how to optimize two parameters <code>TWDI</code> and <code>SPAN</code> in leaf_dynamics model using a differentiable version of leaf_dynamics. The optimization will be done using the Adam optimizer from <code>torch.optim</code>.</p>"},{"location":"notebooks/optimization_leaf_dynamics/#11-software-requirements","title":"1.1 software requirements\u00b6","text":"<p>To run this notebook, we need to install the <code>diffwofost</code>; the differentiable version of WOFOST models. Since the package is constantly under development, make sure you have the latest version of <code>diffwofost</code> installed in your python environment. You can install it using pip:</p>"},{"location":"notebooks/optimization_leaf_dynamics/#12-data","title":"1.2. Data\u00b6","text":"<p>A test dataset of <code>LAI</code> (Leaf area index, including stem and pod area) and <code>TWLV</code> (Dry weight of total leaves (living + dead)) will be used to optimize parametesr <code>TWDI</code> (total initial dry weight) and <code>SPAN</code> (life span of leaves). Note that in leaf_dynamic, changes in <code>SPAN</code> dont affect <code>TWLV</code>.</p> <p>The data is stored in PCSE tests folder, and can be doewnloded from PCSE repsository. You can select any of the files related to <code>leaf_dynamics</code> model with a file name that follwos the pattern <code>test_leafdynamics_wofost72_*.yaml</code>. Each file contains different data depending on the locatin and crop type. For example, you can download the file \"test_leafdynamics_wofost72_01.yaml\" as:</p>"},{"location":"notebooks/optimization_leaf_dynamics/#13-helper-classesfunctions","title":"1.3. Helper classes/functions\u00b6","text":"<p>The model parameters shoudl stay in a valid range. To ensure this, we will use <code>BoundedParameter</code> class with (min, max) and initial values for each parameter. You might change these values depending on the crop type and location. But dont use a very small range, otherwise gradiants will be very small and the optimization will be very slow.</p>"},{"location":"notebooks/optimization_phenology/","title":"Optimization phenology","text":"Optimizing parameters in a WOFOST crop model using <code>diffWOFOST</code> <p>This Jupyter notebook demonstrates the optimization of parameters in a differentiable model using the <code>diffwofost</code> package. The package provides differentiable implementations of the WOFOST model and its associated sub-models. As <code>diffwofost</code> is under active development, this notebook focuses on one sub-models: <code>phenology</code>.</p> In\u00a0[\u00a0]: Copied! <pre># install diffwofost\n!pip install diffwofost\n</pre> # install diffwofost !pip install diffwofost In\u00a0[1]: Copied! <pre># ---- import libraries ----\nimport copy\nimport torch\nimport numpy\nfrom pathlib import Path\nfrom diffwofost.physical_models.config import Configuration\nfrom diffwofost.physical_models.crop.phenology import DVS_Phenology\nfrom diffwofost.physical_models.utils import EngineTestHelper\nfrom diffwofost.physical_models.utils import prepare_engine_input\nfrom diffwofost.physical_models.utils import get_test_data\n</pre> # ---- import libraries ---- import copy import torch import numpy from pathlib import Path from diffwofost.physical_models.config import Configuration from diffwofost.physical_models.crop.phenology import DVS_Phenology from diffwofost.physical_models.utils import EngineTestHelper from diffwofost.physical_models.utils import prepare_engine_input from diffwofost.physical_models.utils import get_test_data In\u00a0[\u00a0]: Copied! <pre># --- run on CPU ------\nfrom diffwofost.physical_models.config import ComputeConfig\nComputeConfig.set_device('cpu')\n</pre> # --- run on CPU ------ from diffwofost.physical_models.config import ComputeConfig ComputeConfig.set_device('cpu') In\u00a0[2]: Copied! <pre># ---- disable a warning: this will be fixed in the future ----\nimport warnings\nwarnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\")\n</pre> # ---- disable a warning: this will be fixed in the future ---- import warnings warnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\") In\u00a0[8]: Copied! <pre>import urllib.request\n\nfilename = \"test_phenology_wofost72_17.yaml\"\nurl = f\"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/{filename}\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> import urllib.request  filename = \"test_phenology_wofost72_17.yaml\" url = f\"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/{filename}\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: test_phenology_wofost72_17.yaml\n</pre> In\u00a0[9]: Copied! <pre># ---- Check the path to the files that are downloaded as explained above ----\ntest_data_path = \"test_phenology_wofost72_17.yaml\"\n</pre> # ---- Check the path to the files that are downloaded as explained above ---- test_data_path = \"test_phenology_wofost72_17.yaml\" In\u00a0[10]: Copied! <pre># ---- Here we read the test data and set some variables ----\ntest_data = get_test_data(test_data_path)\n\ncrop_model_params = [\n    \"TSUMEM\",\n    \"TBASEM\",\n    \"TEFFMX\",\n    \"TSUM1\",\n    \"TSUM2\",\n    \"IDSL\",\n    \"DLO\",\n    \"DLC\",\n    \"DVSI\",\n    \"DVSEND\",\n    \"DTSMTB\",\n    \"VERNSAT\",\n    \"VERNBASE\",\n    \"VERNDVS\",\n]\n(crop_model_params_provider, weather_data_provider, agro_management_inputs, _) = (\n    prepare_engine_input(test_data, crop_model_params)\n)\n\nexpected_results = test_data[\"ModelResults\"]\nexpected_dvs = torch.tensor([float(item[\"DVS\"]) for item in expected_results], dtype=torch.float32\n) # shape: [time_steps]\n\n# ---- don't change this: in this config file we specify the differentiable version of DVS_Phenology ----\nphenology_config = Configuration(\n    CROP=DVS_Phenology,\n    OUTPUT_VARS=[\"DVR\", \"DVS\", \"TSUM\", \"TSUME\", \"VERN\"],\n)\n</pre> # ---- Here we read the test data and set some variables ---- test_data = get_test_data(test_data_path)  crop_model_params = [     \"TSUMEM\",     \"TBASEM\",     \"TEFFMX\",     \"TSUM1\",     \"TSUM2\",     \"IDSL\",     \"DLO\",     \"DLC\",     \"DVSI\",     \"DVSEND\",     \"DTSMTB\",     \"VERNSAT\",     \"VERNBASE\",     \"VERNDVS\", ] (crop_model_params_provider, weather_data_provider, agro_management_inputs, _) = (     prepare_engine_input(test_data, crop_model_params) )  expected_results = test_data[\"ModelResults\"] expected_dvs = torch.tensor([float(item[\"DVS\"]) for item in expected_results], dtype=torch.float32 ) # shape: [time_steps]  # ---- don't change this: in this config file we specify the differentiable version of DVS_Phenology ---- phenology_config = Configuration(     CROP=DVS_Phenology,     OUTPUT_VARS=[\"DVR\", \"DVS\", \"TSUM\", \"TSUME\", \"VERN\"], ) In\u00a0[11]: Copied! <pre># ---- Adjust the values if needed  ----\nTSUMEM_MIN, TSUMEM_MAX, TSUMEM_INIT = (0.0, 200, 90)\nTBASEM_MIN, TBASEM_MAX, TBASEM_INIT = (0.0, 10.0, 2.0)\nTSUM1_MIN, TSUM1_MAX, TSUM1_INIT = (0.0, 1000, 800)\nTSUM2_MIN, TSUM2_MAX, TSUM2_INIT = (0.0, 1000, 800)\n\n# ---- Helper for bounded parameters ----\nclass BoundedParameter(torch.nn.Module):\n    def __init__(self, low, high, init_value):\n        super().__init__()\n        self.low = low\n        self.high = high\n\n        # Normalize to [0, 1]\n        init_norm = (init_value - low) / (high - low)\n\n        # Parameter in raw logit space\n        self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))\n\n    def forward(self):\n        return self.low + (self.high - self.low) * torch.sigmoid(self.raw)\n</pre> # ---- Adjust the values if needed  ---- TSUMEM_MIN, TSUMEM_MAX, TSUMEM_INIT = (0.0, 200, 90) TBASEM_MIN, TBASEM_MAX, TBASEM_INIT = (0.0, 10.0, 2.0) TSUM1_MIN, TSUM1_MAX, TSUM1_INIT = (0.0, 1000, 800) TSUM2_MIN, TSUM2_MAX, TSUM2_INIT = (0.0, 1000, 800)  # ---- Helper for bounded parameters ---- class BoundedParameter(torch.nn.Module):     def __init__(self, low, high, init_value):         super().__init__()         self.low = low         self.high = high          # Normalize to [0, 1]         init_norm = (init_value - low) / (high - low)          # Parameter in raw logit space         self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))      def forward(self):         return self.low + (self.high - self.low) * torch.sigmoid(self.raw)  <p>Another helper class is <code>OptDiffPhenology</code> which is a subclass of <code>torch.nn.Module</code>. We use this class to wrap the <code>EngineTestHelper</code> function and make it easier to run the model <code>phenology</code>.</p> In\u00a0[12]: Copied! <pre># ---- Wrap the model with torch.nn.Module----\nclass OptDiffPhenology(torch.nn.Module):\n    def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, phenology_config):\n        super().__init__()\n        self.crop_model_params_provider = crop_model_params_provider\n        self.weather_data_provider = weather_data_provider\n        self.agro_management_inputs = agro_management_inputs\n        self.config = phenology_config\n\n        # bounded parameters\n        self.TSUMEM = BoundedParameter(TSUMEM_MIN, TSUMEM_MAX, TSUMEM_INIT)\n        self.TBASEM = BoundedParameter(TBASEM_MIN, TBASEM_MAX, TBASEM_INIT)\n        self.TSUM1 = BoundedParameter(TSUM1_MIN, TSUM1_MAX, TSUM1_INIT)\n        self.TSUM2 = BoundedParameter(TSUM2_MIN, TSUM2_MAX, TSUM2_INIT)\n\n    def forward(self):\n        # currently, copying is needed due to an internal issue in engine\n        crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)\n\n        TSUMEM_val = self.TSUMEM()\n        TBASEM_val = self.TBASEM()\n        TSUM1_val = self.TSUM1()\n        TSUM2_val = self.TSUM2()\n        \n        # pass new value of parameters to the model\n        crop_model_params_provider_.set_override(\"TSUMEM\", TSUMEM_val, check=False)\n        crop_model_params_provider_.set_override(\"TBASEM\", TBASEM_val, check=False)\n        crop_model_params_provider_.set_override(\"TSUM1\", TSUM1_val, check=False)\n        crop_model_params_provider_.set_override(\"TSUM2\", TSUM2_val, check=False)\n\n        engine = EngineTestHelper(\n            crop_model_params_provider_,\n            self.weather_data_provider,\n            self.agro_management_inputs,\n            self.config,\n        )\n        engine.run_till_terminate()\n        results = engine.get_output()\n        \n        return torch.stack([item[\"DVS\"] for item in results]) # shape: [1, time_steps]\n</pre> # ---- Wrap the model with torch.nn.Module---- class OptDiffPhenology(torch.nn.Module):     def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, phenology_config):         super().__init__()         self.crop_model_params_provider = crop_model_params_provider         self.weather_data_provider = weather_data_provider         self.agro_management_inputs = agro_management_inputs         self.config = phenology_config          # bounded parameters         self.TSUMEM = BoundedParameter(TSUMEM_MIN, TSUMEM_MAX, TSUMEM_INIT)         self.TBASEM = BoundedParameter(TBASEM_MIN, TBASEM_MAX, TBASEM_INIT)         self.TSUM1 = BoundedParameter(TSUM1_MIN, TSUM1_MAX, TSUM1_INIT)         self.TSUM2 = BoundedParameter(TSUM2_MIN, TSUM2_MAX, TSUM2_INIT)      def forward(self):         # currently, copying is needed due to an internal issue in engine         crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)          TSUMEM_val = self.TSUMEM()         TBASEM_val = self.TBASEM()         TSUM1_val = self.TSUM1()         TSUM2_val = self.TSUM2()                  # pass new value of parameters to the model         crop_model_params_provider_.set_override(\"TSUMEM\", TSUMEM_val, check=False)         crop_model_params_provider_.set_override(\"TBASEM\", TBASEM_val, check=False)         crop_model_params_provider_.set_override(\"TSUM1\", TSUM1_val, check=False)         crop_model_params_provider_.set_override(\"TSUM2\", TSUM2_val, check=False)          engine = EngineTestHelper(             crop_model_params_provider_,             self.weather_data_provider,             self.agro_management_inputs,             self.config,         )         engine.run_till_terminate()         results = engine.get_output()                  return torch.stack([item[\"DVS\"] for item in results]) # shape: [1, time_steps] In\u00a0[13]: Copied! <pre># ----  Create model ---- \nopt_model = OptDiffPhenology(\n    crop_model_params_provider,\n    weather_data_provider,\n    agro_management_inputs,\n    phenology_config,\n)\n</pre> # ----  Create model ----  opt_model = OptDiffPhenology(     crop_model_params_provider,     weather_data_provider,     agro_management_inputs,     phenology_config, ) In\u00a0[14]: Copied! <pre># ----  Early stopping ---- \nbest_loss = float(\"inf\")\npatience = 10  # Number of steps to wait for improvement\npatience_counter = 0\nmin_delta = 1e-4 \n\n# ----  Optimizer ---- \noptimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)\n\n# ----  We use relative MAE as loss because there are two outputs with different untis ----  \ndenom = torch.mean(torch.abs(expected_dvs)) \n\n# Training loop (example)\nfor step in range(101):\n    optimizer.zero_grad()\n    results = opt_model() \n    \n    # phenology parameters can change the simulation duration\n    min_len = min(len(results), len(expected_dvs))\n    if len(results) != len(expected_dvs):\n        print(f\"Step {step}: duration mismatch ({len(results)} vs {len(expected_dvs)}).\")\n        \n    mae = torch.mean(torch.abs(results[:min_len] - expected_dvs[:min_len]))\n    loss = mae / denom  # example: relative mean absolute error\n    loss.backward()\n    optimizer.step()\n\n    print(\n        f\"Step {step}, Loss {loss.item():.4f}, \"\n        f\"TSUMEM {opt_model.TSUMEM().item():.4f}, \"\n        f\"TBASEM {opt_model.TBASEM().item():.4f}, \"\n        f\"TSUM1 {opt_model.TSUM1().item():.4f}, \"\n        f\"TSUM2 {opt_model.TSUM2().item():.4f},\"\n    )\n        \n    # Early stopping logic\n    if loss.item() &lt; best_loss - min_delta:\n        best_loss = loss.item()\n        patience_counter = 0\n    else:\n        patience_counter += 1\n        if patience_counter &gt;= patience:\n            print(f\"Early stopping at step {step}\")\n            print(f\"duration (model {len(results)} vs test {len(expected_dvs)}).\")\n            break\n</pre> # ----  Early stopping ----  best_loss = float(\"inf\") patience = 10  # Number of steps to wait for improvement patience_counter = 0 min_delta = 1e-4   # ----  Optimizer ----  optimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)  # ----  We use relative MAE as loss because there are two outputs with different untis ----   denom = torch.mean(torch.abs(expected_dvs))   # Training loop (example) for step in range(101):     optimizer.zero_grad()     results = opt_model()           # phenology parameters can change the simulation duration     min_len = min(len(results), len(expected_dvs))     if len(results) != len(expected_dvs):         print(f\"Step {step}: duration mismatch ({len(results)} vs {len(expected_dvs)}).\")              mae = torch.mean(torch.abs(results[:min_len] - expected_dvs[:min_len]))     loss = mae / denom  # example: relative mean absolute error     loss.backward()     optimizer.step()      print(         f\"Step {step}, Loss {loss.item():.4f}, \"         f\"TSUMEM {opt_model.TSUMEM().item():.4f}, \"         f\"TBASEM {opt_model.TBASEM().item():.4f}, \"         f\"TSUM1 {opt_model.TSUM1().item():.4f}, \"         f\"TSUM2 {opt_model.TSUM2().item():.4f},\"     )              # Early stopping logic     if loss.item() &lt; best_loss - min_delta:         best_loss = loss.item()         patience_counter = 0     else:         patience_counter += 1         if patience_counter &gt;= patience:             print(f\"Early stopping at step {step}\")             print(f\"duration (model {len(results)} vs test {len(expected_dvs)}).\")             break <pre>Step 0: duration mismatch (260 vs 279).\nStep 0, Loss 0.1490, TSUMEM 85.0787, TBASEM 1.8448, TSUM1 815.5215, TSUM2 815.5215,\nStep 1: duration mismatch (262 vs 279).\nStep 1, Loss 0.1348, TSUMEM 80.2344, TBASEM 1.6999, TSUM1 830.0543, TSUM2 830.0643,\nStep 2: duration mismatch (263 vs 279).\nStep 2, Loss 0.1197, TSUMEM 77.2860, TBASEM 1.6076, TSUM1 843.6052, TSUM2 843.6012,\nStep 3: duration mismatch (264 vs 279).\nStep 3, Loss 0.1147, TSUMEM 76.5338, TBASEM 1.5720, TSUM1 856.1688, TSUM2 856.1740,\nStep 4: duration mismatch (266 vs 279).\nStep 4, Loss 0.1019, TSUMEM 77.1810, TBASEM 1.5731, TSUM1 867.7785, TSUM2 867.8158,\nStep 5: duration mismatch (267 vs 279).\nStep 5, Loss 0.0881, TSUMEM 78.6763, TBASEM 1.5976, TSUM1 878.4762, TSUM2 878.5369,\nStep 6: duration mismatch (268 vs 279).\nStep 6, Loss 0.0830, TSUMEM 80.7683, TBASEM 1.6402, TSUM1 888.2892, TSUM2 888.3950,\nStep 7: duration mismatch (269 vs 279).\nStep 7, Loss 0.0698, TSUMEM 82.9896, TBASEM 1.6870, TSUM1 897.2725, TSUM2 897.4227,\nStep 8: duration mismatch (270 vs 279).\nStep 8, Loss 0.0568, TSUMEM 84.5758, TBASEM 1.7161, TSUM1 905.4835, TSUM2 905.6589,\nStep 9: duration mismatch (271 vs 279).\nStep 9, Loss 0.0521, TSUMEM 84.9177, TBASEM 1.7125, TSUM1 912.9635, TSUM2 913.1725,\nStep 10: duration mismatch (271 vs 279).\nStep 10, Loss 0.0480, TSUMEM 84.3238, TBASEM 1.6843, TSUM1 919.7631, TSUM2 920.0091,\nStep 11: duration mismatch (273 vs 279).\nStep 11, Loss 0.0381, TSUMEM 83.4182, TBASEM 1.6478, TSUM1 925.9421, TSUM2 926.2325,\nStep 12: duration mismatch (273 vs 279).\nStep 12, Loss 0.0355, TSUMEM 82.3086, TBASEM 1.6063, TSUM1 931.5499, TSUM2 931.8865,\nStep 13: duration mismatch (273 vs 279).\nStep 13, Loss 0.0324, TSUMEM 81.3026, TBASEM 1.5680, TSUM1 936.6345, TSUM2 937.0161,\nStep 14: duration mismatch (275 vs 279).\nStep 14, Loss 0.0245, TSUMEM 80.8495, TBASEM 1.5439, TSUM1 941.2473, TSUM2 941.6774,\nStep 15: duration mismatch (275 vs 279).\nStep 15, Loss 0.0220, TSUMEM 81.1065, TBASEM 1.5381, TSUM1 945.4302, TSUM2 945.9092,\nStep 16: duration mismatch (275 vs 279).\nStep 16, Loss 0.0197, TSUMEM 81.9637, TBASEM 1.5478, TSUM1 949.2226, TSUM2 949.7485,\nStep 17: duration mismatch (276 vs 279).\nStep 17, Loss 0.0103, TSUMEM 83.1409, TBASEM 1.5657, TSUM1 952.6663, TSUM2 953.2308,\nStep 18: duration mismatch (277 vs 279).\nStep 18, Loss 0.0093, TSUMEM 84.1272, TBASEM 1.5787, TSUM1 955.4659, TSUM2 956.3961,\nStep 19: duration mismatch (277 vs 279).\nStep 19, Loss 0.0093, TSUMEM 84.7385, TBASEM 1.5820, TSUM1 957.7150, TSUM2 959.2729,\nStep 20: duration mismatch (277 vs 279).\nStep 20, Loss 0.0093, TSUMEM 85.0120, TBASEM 1.5765, TSUM1 959.5129, TSUM2 961.8885,\nStep 21: duration mismatch (277 vs 279).\nStep 21, Loss 0.0092, TSUMEM 84.9791, TBASEM 1.5633, TSUM1 960.9411, TSUM2 964.2680,\nStep 22: duration mismatch (277 vs 279).\nStep 22, Loss 0.0091, TSUMEM 84.6666, TBASEM 1.5432, TSUM1 962.0599, TSUM2 966.4341,\nStep 23: duration mismatch (278 vs 279).\nStep 23, Loss 0.0090, TSUMEM 84.0982, TBASEM 1.5171, TSUM1 962.9180, TSUM2 968.4114,\nStep 24, Loss 0.0078, TSUMEM 83.4926, TBASEM 1.4905, TSUM1 963.5505, TSUM2 970.0585,\nStep 25, Loss 0.0082, TSUMEM 83.2271, TBASEM 1.4719, TSUM1 963.9872, TSUM2 971.4006,\nStep 26, Loss 0.0086, TSUMEM 83.4078, TBASEM 1.4639, TSUM1 964.2517, TSUM2 972.4788,\nStep 27, Loss 0.0090, TSUMEM 83.9896, TBASEM 1.4651, TSUM1 964.3623, TSUM2 973.3393,\nStep 28, Loss 0.0092, TSUMEM 84.8013, TBASEM 1.4715, TSUM1 964.3331, TSUM2 974.0173,\nStep 29, Loss 0.0093, TSUMEM 85.4506, TBASEM 1.4742, TSUM1 964.1751, TSUM2 974.5405,\nStep 30, Loss 0.0094, TSUMEM 85.9211, TBASEM 1.4726, TSUM1 963.8970, TSUM2 974.9305,\nStep 31, Loss 0.0094, TSUMEM 86.0486, TBASEM 1.4633, TSUM1 963.5046, TSUM2 975.2042,\nStep 32, Loss 0.0093, TSUMEM 85.8631, TBASEM 1.4471, TSUM1 963.0023, TSUM2 975.3755,\nStep 33, Loss 0.0092, TSUMEM 85.6006, TBASEM 1.4293, TSUM1 962.3921, TSUM2 975.4550,\nStep 34, Loss 0.0090, TSUMEM 85.2661, TBASEM 1.4101, TSUM1 961.6753, TSUM2 975.4510,\nEarly stopping at step 34\nduration (model 279 vs test 279).\n</pre> In\u00a0[15]: Copied! <pre># ---- validate the results using test data ---- \nprint(\n    f\"Actual TSUMEM {crop_model_params_provider[\"TSUMEM\"].item():.4f}\",\n    f\"TBASEM {crop_model_params_provider[\"TBASEM\"].item():.4f}\",\n    f\"Actual TSUM1 {crop_model_params_provider[\"TSUM1\"].item():.4f}\", \n    f\"TSUM2 {crop_model_params_provider[\"TSUM2\"].item():.4f}\"\n)\n</pre> # ---- validate the results using test data ----  print(     f\"Actual TSUMEM {crop_model_params_provider[\"TSUMEM\"].item():.4f}\",     f\"TBASEM {crop_model_params_provider[\"TBASEM\"].item():.4f}\",     f\"Actual TSUM1 {crop_model_params_provider[\"TSUM1\"].item():.4f}\",      f\"TSUM2 {crop_model_params_provider[\"TSUM2\"].item():.4f}\" ) <pre>Actual TSUMEM 110.0000 TBASEM 0.0000 Actual TSUM1 950.0000 TSUM2 991.0000\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/optimization_phenology/#1-phenology","title":"1. Phenology\u00b6","text":"<p>In this section, we will demonstrate how to optimize the parameters <code>TSUMEM</code>, <code>TBASEM</code>, <code>TSUM1</code> and <code>TSUM2</code>in phenology model using a differentiable version of phenology. The optimization will be done using the Adam optimizer from <code>torch.optim</code>.</p>"},{"location":"notebooks/optimization_phenology/#11-software-requirements","title":"1.1 software requirements\u00b6","text":"<p>To run this notebook, we need to install the <code>diffwofost</code>; the differentiable version of WOFOST models. Since the package is constantly under development, make sure you have the latest version of <code>diffwofost</code> installed in your python environment. You can install it using pip:</p>"},{"location":"notebooks/optimization_phenology/#12-data","title":"1.2. Data\u00b6","text":"<p>A test dataset of <code>DVS</code> (Development stage) will be used to optimize the parameters:</p> <ul> <li><code>TSUMEM</code>: Temperature sum from sowing to emergence,</li> <li><code>TBASEM</code>: Base temperature for emergence,</li> <li><code>TSUM1</code>: Temperature sum from emergence to anthesis,</li> <li><code>TSUM2</code>: Temperature sum from anthesis to maturity.</li> </ul> <p>The data is stored in the PCSE tests folder, and can be downloaded from the PCSE repository. You can select any of the files related to <code>phenology</code> model with a file name that follows the pattern <code>test_phenology_wofost72_*.yaml</code>. Each file contains different data depending on the location and crop type. For example, you can download the file \"test_phenology_wofost72_01.yaml\" as:</p>"},{"location":"notebooks/optimization_phenology/#13-helper-classesfunctions","title":"1.3. Helper classes/functions\u00b6","text":"<p>The model parameters should stay in a valid range. To ensure this, we will use <code>BoundedParameter</code> class with (min, max) and initial values for each parameter. You may change these values depending on the crop type and location. But don't use a very small range, otherwise gradients will be very small and the optimization will be very slow.</p>"},{"location":"notebooks/optimization_root_dynamics/","title":"install diffwofost","text":"Optimizing parameters in a WOFOST crop model using <code>diffWOFOST</code> <p>This Jupyter notebook demonstrates the optimization of parameters in a differentiable model using the <code>diffwofost</code> package. The package provides differentiable implementations of the WOFOST model and its associated sub-models. As <code>diffwofost</code> is under active development, this notebook focuses on <code>root_dynamics</code>.</p> <p>To enable these models to operate independently, certain state variables required by the model are supplied as \"external states\" derived from the test data. Also, at this stage, only a limited subset of model parameters has been made differentiable.</p> In\u00a0[\u00a0]: Copied! <pre># install diffwofost\n!pip install diffwofost\n</pre> # install diffwofost !pip install diffwofost In\u00a0[2]: Copied! <pre># ---- import libraries ----\nimport copy\nimport torch\nimport numpy\nimport yaml\nfrom pathlib import Path\nfrom diffwofost.physical_models.config import Configuration\nfrom diffwofost.physical_models.crop.root_dynamics import WOFOST_Root_Dynamics\nfrom diffwofost.physical_models.utils import EngineTestHelper\nfrom diffwofost.physical_models.utils import prepare_engine_input\nfrom diffwofost.physical_models.utils import get_test_data\n</pre> # ---- import libraries ---- import copy import torch import numpy import yaml from pathlib import Path from diffwofost.physical_models.config import Configuration from diffwofost.physical_models.crop.root_dynamics import WOFOST_Root_Dynamics from diffwofost.physical_models.utils import EngineTestHelper from diffwofost.physical_models.utils import prepare_engine_input from diffwofost.physical_models.utils import get_test_data In\u00a0[\u00a0]: Copied! <pre># --- run on CPU ------\nfrom diffwofost.physical_models.config import ComputeConfig\nComputeConfig.set_device('cpu')\n</pre> # --- run on CPU ------ from diffwofost.physical_models.config import ComputeConfig ComputeConfig.set_device('cpu') In\u00a0[3]: Copied! <pre># ---- disable a warning: this will be fixed in the future ----\nimport warnings\nwarnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\")\n</pre> # ---- disable a warning: this will be fixed in the future ---- import warnings warnings.filterwarnings(\"ignore\", message=\"To copy construct from a tensor.*\") In\u00a0[4]: Copied! <pre>import urllib.request\n\nurl = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_rootdynamics_wofost72_01.yaml\"\nfilename = \"test_rootdynamics_wofost72_01.yaml\"\n\nurllib.request.urlretrieve(url, filename)\nprint(f\"Downloaded: {filename}\")\n</pre> import urllib.request  url = \"https://raw.githubusercontent.com/ajwdewit/pcse/refs/heads/master/tests/test_data/test_rootdynamics_wofost72_01.yaml\" filename = \"test_rootdynamics_wofost72_01.yaml\"  urllib.request.urlretrieve(url, filename) print(f\"Downloaded: {filename}\") <pre>Downloaded: test_rootdynamics_wofost72_01.yaml\n</pre> <p>We also need to download a config file to be able to run each crop module. This will change in the future versions. To donwload the config file, you can use the following command:</p> In\u00a0[5]: Copied! <pre># ---- Check the path to the files that are downloaded as explained above ----\ntest_data_path = \"test_rootdynamics_wofost72_01.yaml\"\n</pre> # ---- Check the path to the files that are downloaded as explained above ---- test_data_path = \"test_rootdynamics_wofost72_01.yaml\" In\u00a0[6]: Copied! <pre># ---- Here we read the test data and set some variables ----\ntest_data = get_test_data(test_data_path)\n(crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (\n    prepare_engine_input(test_data, [\"RDI\", \"RRI\", \"RDMCR\", \"RDMSOL\", \"TDWI\", \"IAIRDU\"])\n)\n\nexpected_results = test_data[\"ModelResults\"]\nexpected_twrt = torch.tensor(\n    [float(item[\"TWRT\"]) for item in expected_results], dtype=torch.float32\n) # shape: [1, time_steps]\n\n# ---- dont change this: in this config file we specified the diffrentiable version of root_dynamics ----\nroot_dynamics_config = Configuration(\n    CROP=WOFOST_Root_Dynamics,\n    OUTPUT_VARS=[\"RD\", \"TWRT\"],\n)\n</pre> # ---- Here we read the test data and set some variables ---- test_data = get_test_data(test_data_path) (crop_model_params_provider, weather_data_provider, agro_management_inputs, external_states) = (     prepare_engine_input(test_data, [\"RDI\", \"RRI\", \"RDMCR\", \"RDMSOL\", \"TDWI\", \"IAIRDU\"]) )  expected_results = test_data[\"ModelResults\"] expected_twrt = torch.tensor(     [float(item[\"TWRT\"]) for item in expected_results], dtype=torch.float32 ) # shape: [1, time_steps]  # ---- dont change this: in this config file we specified the diffrentiable version of root_dynamics ---- root_dynamics_config = Configuration(     CROP=WOFOST_Root_Dynamics,     OUTPUT_VARS=[\"RD\", \"TWRT\"], ) In\u00a0[7]: Copied! <pre># ---- Adjust the values if needed  ----\nTDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.30)\n\n# ---- Helper for bounded parameters ----\nclass BoundedParameter(torch.nn.Module):\n    def __init__(self, low, high, init_value):\n        super().__init__()\n        self.low = low\n        self.high = high\n\n        # Normalize to [0, 1]\n        init_norm = (init_value - low) / (high - low)\n\n        # Parameter in raw logit space\n        self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))\n\n    def forward(self):\n        return self.low + (self.high - self.low) * torch.sigmoid(self.raw)\n</pre> # ---- Adjust the values if needed  ---- TDWI_MIN, TDWI_MAX, TDWI_INIT = (0.0, 1.0, 0.30)  # ---- Helper for bounded parameters ---- class BoundedParameter(torch.nn.Module):     def __init__(self, low, high, init_value):         super().__init__()         self.low = low         self.high = high          # Normalize to [0, 1]         init_norm = (init_value - low) / (high - low)          # Parameter in raw logit space         self.raw = torch.nn.Parameter(torch.logit(torch.tensor(init_norm, dtype=torch.float32), eps=1e-6))      def forward(self):         return self.low + (self.high - self.low) * torch.sigmoid(self.raw)  <p>Another helper class is <code>OptRootDynamics</code> which is a subclass of <code>torch.nn.Module</code>. We use this class to wrap the <code>EngineTestHelper</code> function and make it easier to run the model <code>root_dynamic</code>.</p> In\u00a0[8]: Copied! <pre># ---- Wrap the model with torch.nn.Module----\nclass OptDiffRootDynamics(torch.nn.Module):\n    def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, root_dynamics_config, external_states):\n        super().__init__()\n        self.crop_model_params_provider = crop_model_params_provider\n        self.weather_data_provider = weather_data_provider\n        self.agro_management_inputs = agro_management_inputs\n        self.config = root_dynamics_config\n        self.external_states = external_states\n\n        # bounded parameters\n        self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)\n        \n    def forward(self):\n        # currently, copying is needed due to an internal issue in engine\n        crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)\n        external_states_ = copy.deepcopy(self.external_states)\n        \n        tdwi_val = self.tdwi()\n        \n        # pass new value of parameters to the model\n        crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)\n\n        engine = EngineTestHelper(\n            crop_model_params_provider_,\n            self.weather_data_provider,\n            self.agro_management_inputs,\n            self.config,\n            external_states_,\n        )\n        engine.run_till_terminate()\n        results = engine.get_output()\n        \n        return torch.stack([item[\"TWRT\"] for item in results]) # shape: [1, time_steps]\n</pre> # ---- Wrap the model with torch.nn.Module---- class OptDiffRootDynamics(torch.nn.Module):     def __init__(self, crop_model_params_provider, weather_data_provider, agro_management_inputs, root_dynamics_config, external_states):         super().__init__()         self.crop_model_params_provider = crop_model_params_provider         self.weather_data_provider = weather_data_provider         self.agro_management_inputs = agro_management_inputs         self.config = root_dynamics_config         self.external_states = external_states          # bounded parameters         self.tdwi = BoundedParameter(TDWI_MIN, TDWI_MAX, init_value=TDWI_INIT)              def forward(self):         # currently, copying is needed due to an internal issue in engine         crop_model_params_provider_ = copy.deepcopy(self.crop_model_params_provider)         external_states_ = copy.deepcopy(self.external_states)                  tdwi_val = self.tdwi()                  # pass new value of parameters to the model         crop_model_params_provider_.set_override(\"TDWI\", tdwi_val, check=False)          engine = EngineTestHelper(             crop_model_params_provider_,             self.weather_data_provider,             self.agro_management_inputs,             self.config,             external_states_,         )         engine.run_till_terminate()         results = engine.get_output()                  return torch.stack([item[\"TWRT\"] for item in results]) # shape: [1, time_steps] In\u00a0[9]: Copied! <pre># ----  Create model ---- \nopt_model = OptDiffRootDynamics(\n    crop_model_params_provider,\n    weather_data_provider,\n    agro_management_inputs,\n    root_dynamics_config,\n    external_states,\n)\n</pre> # ----  Create model ----  opt_model = OptDiffRootDynamics(     crop_model_params_provider,     weather_data_provider,     agro_management_inputs,     root_dynamics_config,     external_states, ) In\u00a0[10]: Copied! <pre># ----  Early stopping ---- \nbest_loss = float(\"inf\")\npatience = 10  # Number of steps to wait for improvement\npatience_counter = 0\nmin_delta = 1e-4 \n\n# ----  Optimizer ---- \noptimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)\n\n# ----  We use relative MAE as loss because there are two outputs with different untis ----  \ndenom = torch.mean(torch.abs(expected_twrt)) \n\n# Training loop (example)\nfor step in range(101):\n    optimizer.zero_grad()\n    results = opt_model() \n    mae = torch.mean(torch.abs(results - expected_twrt))\n    loss = mae / denom # example: relative mean absolute error\n    loss.backward()\n    optimizer.step()\n\n    print(f\"Step {step}, Loss {loss.item():.8f}, TDWI {opt_model.tdwi().item():.4f}\")\n    # Early stopping logic\n    if loss.item() &lt; best_loss - min_delta:\n        best_loss = loss.item()\n        patience_counter = 0\n    else:\n        patience_counter += 1\n        if patience_counter &gt;= patience:\n            print(f\"Early stopping at step {step}\")\n            break\n</pre> # ----  Early stopping ----  best_loss = float(\"inf\") patience = 10  # Number of steps to wait for improvement patience_counter = 0 min_delta = 1e-4   # ----  Optimizer ----  optimizer = torch.optim.Adam(opt_model.parameters(), lr=0.1)  # ----  We use relative MAE as loss because there are two outputs with different untis ----   denom = torch.mean(torch.abs(expected_twrt))   # Training loop (example) for step in range(101):     optimizer.zero_grad()     results = opt_model()      mae = torch.mean(torch.abs(results - expected_twrt))     loss = mae / denom # example: relative mean absolute error     loss.backward()     optimizer.step()      print(f\"Step {step}, Loss {loss.item():.8f}, TDWI {opt_model.tdwi().item():.4f}\")     # Early stopping logic     if loss.item() &lt; best_loss - min_delta:         best_loss = loss.item()         patience_counter = 0     else:         patience_counter += 1         if patience_counter &gt;= patience:             print(f\"Early stopping at step {step}\")             break <pre>Step 0, Loss 0.00004644, TDWI 0.3214\nStep 1, Loss 0.00004170, TDWI 0.3436\nStep 2, Loss 0.00003679, TDWI 0.3665\nStep 3, Loss 0.00003172, TDWI 0.3901\nStep 4, Loss 0.00002650, TDWI 0.4143\nStep 5, Loss 0.00002116, TDWI 0.4389\nStep 6, Loss 0.00001571, TDWI 0.4639\nStep 7, Loss 0.00001019, TDWI 0.4891\nStep 8, Loss 0.00000461, TDWI 0.5144\nStep 9, Loss 0.00000099, TDWI 0.5316\nStep 10, Loss 0.00000479, TDWI 0.5424\nEarly stopping at step 10\n</pre> In\u00a0[11]: Copied! <pre># ---- validate the results using test data ---- \nprint(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}\")\n</pre> # ---- validate the results using test data ----  print(f\"Actual TDWI {crop_model_params_provider[\"TDWI\"].item():.4f}\") <pre>Actual TDWI 0.5100\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/optimization_root_dynamics/#1-root-dynamics","title":"1. Root dynamics\u00b6","text":"<p>In this section, we will demonstrate how to optimize two parameters <code>TWDI</code> in root_dynamics model using a differentiable version of root_dynamics. The optimization will be done using the Adam optimizer from <code>torch.optim</code>.</p>"},{"location":"notebooks/optimization_root_dynamics/#11-software-requirements","title":"1.1 software requirements\u00b6","text":"<p>To run this notebook, we need to install the <code>diffwofost</code>; the differentiable version of WOFOST models. Since the package is constantly under development, make sure you have the latest version of <code>diffwofost</code> installed in your python environment. You can install it using pip:</p>"},{"location":"notebooks/optimization_root_dynamics/#install-diffwofost","title":"install diffwofost\u00b6","text":"<p>!pip install diffwofost</p>"},{"location":"notebooks/optimization_root_dynamics/#12-data","title":"1.2. Data\u00b6","text":"<p>A test dataset of <code>TWRT</code> (Total weight of roots) will be used to optimize parametesr <code>TWDI</code> (total initial dry weight). Note that in root_dynamic, changes in <code>TWDI</code> dont affect <code>RD</code> (Current rooting depth).</p> <p>The data is stored in PCSE tests folder, and can be doewnloded from PCSE repsository. You can select any of the files related to <code>root_dynamics</code> model with a file name that follwos the pattern <code>test_rootdynamics_wofost72_*.yaml</code>. Each file contains different data depending on the locatin and crop type. For example, you can download the file \"test_rootdynamics_wofost72_01.yaml\" as:</p>"},{"location":"notebooks/optimization_root_dynamics/#13-helper-classesfunctions","title":"1.3. Helper classes/functions\u00b6","text":"<p>The model parameters shoudl stay in a valid range. To ensure this, we will use <code>BoundedParameter</code> class with (min, max) and initial values for each parameter. You might change these values depending on the crop type and location. But dont use a very small range, otherwise gradiants will be very small and the optimization will be very slow.</p>"}]}